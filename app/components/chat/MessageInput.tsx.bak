"use client";

import React, { 
  useState, 
  useRef, 
  useEffect, 
  useCallback, 
  ChangeEvent, 
  KeyboardEvent, 
  forwardRef, 
  ForwardedRef, 
  MouseEvent
} from 'react';
import type { ReactElement } from 'react';
import { 
  HiPaperClip, 
  HiPhotograph, 
  HiLocationMarker, 
  HiVideoCamera, 
  HiEmojiHappy 
} from 'react-icons/hi';
import { RiSendPlaneFill } from 'react-icons/ri';
import { IoClose } from 'react-icons/io5';
import { FaGift } from 'react-icons/fa';
import { MdWarning } from 'react-icons/md';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import GiftSelector from '@/components/chat/GiftSelector';
import GiftAnimator from './GiftAnimator';
import toast from 'react-hot-toast';
import { 
  Message, 
  AttachmentUnion, 
  ImageAttachment, 
  VideoAttachment, 
  LocationAttachment, 
  GiftAttachment, 
  MessageStatus 
} from '@/app/types/chat';
import { Gift } from '@/types/gift';
import { validateGiftImageUrl, isValidImageUrl } from '@/app/utils/imageHelpers';
import { SafeImage, GiftImage } from '@/app/components/common/SafeImage';

// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç¨®é¡ã‚’è¡¨ã™åˆ—æŒ™å‹
enum AttachmentType {
  IMAGE = 'image',
  VIDEO = 'video',
  LOCATION = 'location',
  GIFT = 'gift'
}

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰çµæœã®å‹å®šç¾©
interface FileUploadResult {
  url: string;
  thumbnailUrl?: string;
}

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—
type FileType = 'image' | 'video';

// ä½ç½®æƒ…å ±ã®å‹å®šç¾©
interface Location {
  name: string;
  latitude: number;
  longitude: number;
  address?: string;
}

// çµµæ–‡å­—ã‚«ãƒ†ã‚´ãƒªãƒ¼ã®å‹å®šç¾©
interface EmojiCategory {
  id: string;
  name: string;
  emojis: string[];
}

// MessageInputã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®propså‹å®šç¾©
interface MessageInputProps {
  onSendMessage: (message: Message) => Promise<void>;
  onTypingStart?: () => void;
  onTypingEnd?: () => void;
  disabled?: boolean;
  placeholder?: string;
  gender: 'male' | 'female';
  currentPoints: number;
  requiredPoints?: number;
  onPointsUpdated?: (points: number) => void;
  chatId: string;
}

// ã‚µãƒ³ãƒ—ãƒ«çµµæ–‡å­—ã‚«ãƒ†ã‚´ãƒªãƒ¼ãƒ‡ãƒ¼ã‚¿
const emojiCategories: EmojiCategory[] = [
  {
    id: 'recent',
    name: 'æœ€è¿‘',
    emojis: ['ğŸ˜€', 'ğŸ˜‚', 'â¤ï¸', 'ğŸ‘', 'ğŸ‰', 'ğŸ”¥', 'ğŸ’¯', 'ğŸ™', 'ğŸ˜Š', 'ğŸ¥°', 'ğŸ˜', 'ğŸ¤”']
  },
  {
    id: 'smileys',
    name: 'ç¬‘é¡”',
    emojis: ['ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ¤£', 'ğŸ˜‚', 'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Š']
  },
  {
    id: 'love',
    name: 'æ„›æƒ…',
    emojis: ['â¤ï¸', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ–¤', 'ğŸ’•', 'ğŸ’', 'ğŸ’“', 'ğŸ’—', 'ğŸ’–']
  }
];

// MessageInputã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
const MessageInput = forwardRef<HTMLDivElement, MessageInputProps>((
  {
    onSendMessage,
    onTypingStart,
    onTypingEnd,
    disabled = false,
    placeholder = 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›',
    gender,
    currentPoints,
    requiredPoints = 1,
    onPointsUpdated,
    chatId
  }: MessageInputProps,
  ref: ForwardedRef<HTMLDivElement>
): ReactElement => {
  // ã‚¹ãƒ†ãƒ¼ãƒˆç®¡ç†
  const [text, setText] = useState<string>('');
  const [attachments, setAttachments] = useState<AttachmentUnion[]>([]);
  const [selectedLocation, setSelectedLocation] = useState<Location | null>(null);
  const [giftAttachment, setGiftAttachment] = useState<GiftAttachment | null>(null);
  const [isAttachmentMenuOpen, setIsAttachmentMenuOpen] = useState<boolean>(false);
  const [isEmojiMenuOpen, setIsEmojiMenuOpen] = useState<boolean>(false);
  const [isSending, setIsSending] = useState<boolean>(false);
  const [localPoints, setLocalPoints] = useState<number>(currentPoints);
  const [showGiftSelector, setShowGiftSelector] = useState<boolean>(false);
  const [selectedGift, setSelectedGift] = useState<Gift | null>(null);
  const [showGiftAnimation, setShowGiftAnimation] = useState<boolean>(false);
  const [currentAnimation, setCurrentAnimation] = useState<string>('');
  const [activeEmojiCategory, setActiveEmojiCategory] = useState<string>('recent');
  
  // å‚ç…§
  const fileInputRef = useRef<HTMLInputElement>(null);
  const videoInputRef = useRef<HTMLInputElement>(null);
  const textAreaRef = useRef<HTMLTextAreaElement>(null);
  const sendingRef = useRef<boolean>(false);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const attachmentMenuRef = useRef<HTMLDivElement>(null);
  const emojiMenuRef = useRef<HTMLDivElement>(null);

  // ãƒ­ãƒ¼ã‚«ãƒ«ãƒã‚¤ãƒ³ãƒˆã‚’propsã¨åŒæœŸ
  useEffect(() => {
    setLocalPoints(currentPoints);
  }, [currentPoints]);

  // disabledãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«æ·»ä»˜ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
  useEffect(() => {
    if (disabled) {
      setIsAttachmentMenuOpen(false);
      setIsEmojiMenuOpen(false);
    }
  }, [disabled]);

  // ãƒ†ã‚­ã‚¹ãƒˆãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«ã‚¿ã‚¤ãƒ”ãƒ³ã‚°çŠ¶æ…‹ã‚’é€šçŸ¥
  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>): void => {
    const newText = e.target.value;
    setText(newText);

    // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°é–‹å§‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
    if (onTypingStart) {
      onTypingStart();
    }

    // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°çµ‚äº†ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    // 3ç§’å¾Œã«ã‚¿ã‚¤ãƒ”ãƒ³ã‚°çµ‚äº†ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
    typingTimeoutRef.current = setTimeout(() => {
      if (onTypingEnd) {
        onTypingEnd();
      }
    }, 3000);
  }, [onTypingStart, onTypingEnd]);

  // æ¤œè¨¼é–¢æ•° - useCallbackã§æœ€é©åŒ–
  const validatePoints = useCallback((points: number = requiredPoints): boolean => {
    // ç”·æ€§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆã®ã¿ãƒã‚¤ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†
    if (gender === 'male') {
      if (localPoints < points) {
        toast.error(`ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦ãƒã‚¤ãƒ³ãƒˆ: ${points}ï¼‰`);
        return false;
      }
    }
    return true;
  }, [gender, localPoints, requiredPoints]);

  const validateGift = useCallback((gift: Gift): boolean => {
    if (gender === 'male' && gift.price) {
      // ç”·æ€§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆã€ã‚®ãƒ•ãƒˆç”¨ã®ãƒã‚¤ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
      if (localPoints < gift.price) {
        toast.error(`ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦ãƒã‚¤ãƒ³ãƒˆ: ${gift.price}ï¼‰`);
        return false;
      }
    }
    return true;
  }, [gender, localPoints]);

  // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é–¢æ•°
  const uploadFile = useCallback(async (file: File, type: FileType): Promise<FileUploadResult> => {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ã“ã“ã§APIã‚’å‘¼ã³å‡ºã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™
    // ã“ã®ã‚µãƒ³ãƒ—ãƒ«ã§ã¯ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™
    return new Promise((resolve) => {
      setTimeout(() => {
        if (type === 'image') {
          resolve({
            url: URL.createObjectURL(file),
            thumbnailUrl: URL.createObjectURL(file)
          });
        } else {
          resolve({
            url: URL.createObjectURL(file),
            thumbnailUrl: 'https://via.placeholder.com/300x200?text=Video+Thumbnail'
          });
        }
      }, 1000);
    });
  }, []);

  // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>): void => {
    const newText = e.target.value;
    setText(newText);

    // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆ
    if (onTypingStart) {
      onTypingStart();
    }

    // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°çµ‚äº†åˆ¤å®š
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    typingTimeoutRef.current = setTimeout(() => {
      if (onTypingEnd) {
        onTypingEnd();
      }
    }, 1000);
  }, [onTypingStart, onTypingEnd]);

  // æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®è¡¨ç¤ºåˆ‡æ›¿
  const toggleAttachmentMenu = useCallback((): void => {
    setIsAttachmentMenuOpen(prev => !prev);
    if (isEmojiMenuOpen) {
      setIsEmojiMenuOpen(false);
    }
  }, [isEmojiMenuOpen]);

  // çµµæ–‡å­—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®è¡¨ç¤ºåˆ‡æ›¿
  const toggleEmojiMenu = useCallback((): void => {
    setIsEmojiMenuOpen(prev => !prev);
    if (isAttachmentMenuOpen) {
      setIsAttachmentMenuOpen(false);
    }
  }, [isAttachmentMenuOpen]);

  // ç”»åƒæ·»ä»˜ãƒˆãƒªã‚¬ãƒ¼
  const triggerImageAttachment = useCallback((): void => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
    setIsAttachmentMenuOpen(false);
  }, []);

  // å‹•ç”»æ·»ä»˜ãƒˆãƒªã‚¬ãƒ¼
  const triggerVideoAttachment = useCallback((): void => {
    if (videoInputRef.current) {
      videoInputRef.current.click();
    }
    setIsAttachmentMenuOpen(false);
  }, []);

  // çµµæ–‡å­—é¸æŠãƒãƒ³ãƒ‰ãƒ©
  const handleEmojiSelect = useCallback((emoji: string): void => {
    setText(prev => prev + emoji);
    if (textAreaRef.current) {
      textAreaRef.current.focus();
    }
  }, []);

  // æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤ãƒãƒ³ãƒ‰ãƒ©
  const handleRemoveAttachment = useCallback((index: number): void => {
    setAttachments(prev => prev.filter((_, i) => i !== index));
  }, []);

  // ã‚¯ãƒªãƒƒã‚¯ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ‰å‡¦ç†
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent): void => {
      if (attachmentMenuRef.current && 
          !attachmentMenuRef.current.contains(event.target as Node) && 
          isAttachmentMenuOpen) {
        setIsAttachmentMenuOpen(false);
      }
      
      if (emojiMenuRef.current && 
          !emojiMenuRef.current.contains(event.target as Node) && 
          isEmojiMenuOpen) {
        setIsEmojiMenuOpen(false);
      }
    };

    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, [isAttachmentMenuOpen, isEmojiMenuOpen]);

  return (
    <div className="relative w-full" ref={ref}>
      <div className="flex items-center bg-white dark:bg-gray-800 rounded-lg p-2 shadow">
        {/* æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ãƒœã‚¿ãƒ³ */}
        <button 
          type="button" 
          className="text-gray-500 hover:text-blue-500 p-2 rounded-full focus:outline-none"
          onClick={toggleAttachmentMenu}
          disabled={disabled || isSending}
        >
          <HiPaperClip className="w-6 h-6" />
        </button>
        
        {/* ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ› */}
        <textarea
          ref={textAreaRef}
          className="flex-1 border-none bg-transparent resize-none focus:outline-none px-2 py-1 min-h-[40px] max-h-[120px] overflow-auto"
          placeholder={placeholder}
          value={text}
          onChange={handleTextChange}
          disabled={disabled || isSending}
          onKeyDown={(e: KeyboardEvent<HTMLTextAreaElement>) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              // sendMessageé–¢æ•°ã¯å¾Œã§å®Ÿè£…ã—ã¾ã™
            }
          }}
        />
        
        {/* çµµæ–‡å­—ãƒœã‚¿ãƒ³ */}
        <button 
          type="button" 
          className="text-gray-500 hover:text-yellow-500 p-2 rounded-full focus:outline-none"
          onClick={toggleEmojiMenu}
          disabled={disabled || isSending}
        >
          <HiEmojiHappy className="w-6 h-6" />
        </button>
        
        {/* ã‚®ãƒ•ãƒˆãƒœã‚¿ãƒ³ - å¾Œã§å®Ÿè£… */}
        <button 
          type="button" 
          className="text-gray-500 hover:text-pink-500 p-2 rounded-full focus:outline-none"
          onClick={() => setShowGiftSelector(true)}
          disabled={disabled || isSending}
        >
          <FaGift className="w-5 h-5" />
        </button>
        
        {/* é€ä¿¡ãƒœã‚¿ãƒ³ */}
        <button 
          type="button" 
          className="text-white bg-blue-600 hover:bg-blue-700 p-2 rounded-full focus:outline-none disabled:opacity-50"
          disabled={disabled || isSending || (!text.trim() && attachments.length === 0 && !selectedLocation && !giftAttachment)}
          // onClick={handleSendMessage} å¾Œã§å®Ÿè£…
        >
          <RiSendPlaneFill className="w-5 h-5" />
        </button>
      </div>

      {/* æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ */}
      {isAttachmentMenuOpen && (
        <div 
          ref={attachmentMenuRef}
          className="absolute bottom-16 left-0 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-3 z-10"
        >
          <div className="flex space-x-4">
            <button 
              type="button" 
              className="flex flex-col items-center text-gray-700 dark:text-gray-300 hover:text-blue-500 focus:outline-none"
              onClick={triggerImageAttachment}
            >
              <HiPhotograph className="w-6 h-6" />
              <span className="text-xs mt-1">ç”»åƒ</span>
            </button>
            <button 
              type="button" 
              className="flex flex-col items-center text-gray-700 dark:text-gray-300 hover:text-blue-500 focus:outline-none"
              onClick={triggerVideoAttachment}
            >
              <HiVideoCamera className="w-6 h-6" />
              <span className="text-xs mt-1">å‹•ç”»</span>
            </button>
            <button 
              type="button" 
              className="flex flex-col items-center text-gray-700 dark:text-gray-300 hover:text-blue-500 focus:outline-none"
              // onClick={handleLocationAttachment} å¾Œã§å®Ÿè£…
            >
              <HiLocationMarker className="w-6 h-6" />
              <span className="text-xs mt-1">ä½ç½®æƒ…å ±</span>
            </button>
          </div>
        </div>
      )}

      {/* çµµæ–‡å­—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ - ç°¡æ˜“å®Ÿè£… */}
      {isEmojiMenuOpen && (
        <div 
          ref={emojiMenuRef}
          className="absolute bottom-16 right-0 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-3 z-10 w-64"
        >
          <div className="mb-2 flex space-x-2 overflow-x-auto pb-2">
            {emojiCategories.map(cat => (
              <button 
                key={cat.id} 
                className="px-3 py-1 text-sm whitespace-nowrap hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
              >
                {cat.name}
              </button>
            ))}
          </div>
          <div className="grid grid-cols-8 gap-1">
            {emojiCategories[0].emojis.map((emoji, index) => (
              <button 
                key={index} 
                className="text-xl p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
                onClick={() => handleEmojiSelect(emoji)}
              >
                {emoji}
              </button>
            ))}
          </div>
        </div>
      )}

      {/* éš ã—ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ› */}
      <input 
        type="file" 
        ref={fileInputRef} 
        accept="image/*" 
        className="hidden" 
        // onChange={handleImageAttachment} å¾Œã§å®Ÿè£…
      />
      <input 
        type="file" 
        ref={videoInputRef} 
        accept="video/*" 
        className="hidden" 
        // onChange={handleVideoAttachment} å¾Œã§å®Ÿè£…
      />

      {/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºã‚¨ãƒªã‚¢ - å¾Œã§å®Ÿè£… */}
    </div>
  );
});

MessageInput.displayName = 'MessageInput';

export default MessageInput;
  // State variables
  const [text, setText] = useState<string>('');
  const [attachments, setAttachments] = useState<AttachmentType[]>([]);
  const [selectedLocation, setSelectedLocation] = useState<Location | null>(null);
  const [giftAttachment, setGiftAttachment] = useState<GiftAttachment | null>(null);
  const [selectedGift, setSelectedGift] = useState<Gift | null>(null);
  const [isAttachmentMenuOpen, setIsAttachmentMenuOpen] = useState<boolean>(false);
  const [isEmoticonPickerOpen, setIsEmoticonPickerOpen] = useState<boolean>(false);
  const [isSending, setIsSending] = useState<boolean>(false);
  const [localPoints, setLocalPoints] = useState<number>(currentPoints);
  const [showGiftSelector, setShowGiftSelector] = useState<boolean>(false);
  const [showGiftAnimation, setShowGiftAnimation] = useState<boolean>(false);
  const [currentAnimation, setCurrentAnimation] = useState<string | null>(null);
  
  // Refs
  const inputRef = useRef<HTMLTextAreaElement | null>(null);
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const videoInputRef = useRef<HTMLInputElement | null>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const attachmentMenuRef = useRef<HTMLDivElement | null>(null);
  const emoticonPickerRef = useRef<HTMLDivElement | null>(null);
  const sendingRef = useRef<boolean>(false);


const MessageInput = React.forwardRef<HTMLDivElement, MessageInputProps>(({ 
  onSendMessage,
  onTypingStart,
  onTypingEnd,
  disabled = false,
  placeholder = 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...',
  gender,
  currentPoints,
  requiredPoints,
  onPointsUpdated,
  chatId
}, ref): ReactElement => {
  // State
  const [text, setText] = useState<string>('');
  const [attachments, setAttachments] = useState<Attachment[]>([]);
  const [selectedLocation, setSelectedLocation] = useState<Location | null>(null);
  const [giftAttachment, setGiftAttachment] = useState<GiftAttachment | null>(null);
  const [selectedGift, setSelectedGift] = useState<Gift | null>(null);
  const [showGiftSelector, setShowGiftSelector] = useState<boolean>(false);
  const [showGiftAnimation, setShowGiftAnimation] = useState<boolean>(false);
  const [currentAnimation, setCurrentAnimation] = useState<string>('');
  const [isSending, setIsSending] = useState<boolean>(false);
  const [localPoints, setLocalPoints] = useState<number>(currentPoints);
  const [isAttachmentMenuOpen, setIsAttachmentMenuOpen] = useState<boolean>(false);
  const [isEmoticonPickerOpen, setIsEmoticonPickerOpen] = useState<boolean>(false);
  const [activeEmojiCategory, setActiveEmojiCategory] = useState<string>('smileys');

  // Refs
  const sendingRef = useRef<boolean>(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const videoInputRef = useRef<HTMLInputElement>(null);
  const attachmentButtonRef = useRef<HTMLButtonElement>(null);
  const emoticonButtonRef = useRef<HTMLButtonElement>(null);
  const giftButtonRef = useRef<HTMLButtonElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout>();

  // Update local points when prop changes
  useEffect(() => {
    setLocalPoints(currentPoints);
  }, [currentPoints]);

  // Validation functions
  const validatePoints = useCallback((points: number): boolean => {
    if (!points || points <= 0) return false;
    if (gender === 'male' && localPoints < points) {
      toast.error(`ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦ãƒã‚¤ãƒ³ãƒˆ: ${points}ï¼‰`);
      return false;
    }
    return true;
  }, [localPoints, gender]);

  const validateGift = useCallback((gift: Gift | null): boolean => {
    if (!gift || !gift.price) {
      toast.error('ã‚®ãƒ•ãƒˆã®æƒ…å ±ãŒä¸æ­£ã§ã™');
      return false;
    }
    
    if (!gift.imageUrl || !validateGiftImageUrl(gift.imageUrl)) {
      toast.error('ã‚®ãƒ•ãƒˆç”»åƒãŒç„¡åŠ¹ã§ã™');
      return false;
    }

    if (gender === 'male') {
      return validatePoints(gift.price);
    }

    return true;
  }, [gender, validatePoints]);

  if (!onSendMessage || !onPointsUpdated) {
    return <div ref={ref}>Error: Required props missing</div>;
  }



  // Message handlers
  const handleTextChange = useCallback((e: ChangeEvent<HTMLTextAreaElement>): void => {
    const newText = e.target.value;
    setText(newText);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    if (newText.trim() && onTypingStart) {
      onTypingStart();
    }

    typingTimeoutRef.current = setTimeout(() => {
      if (onTypingEnd) onTypingEnd();
    }, 1000);

    if (!newText.trim() && onTypingEnd) {
      onTypingEnd();
    }
  }, [onTypingStart, onTypingEnd]);

  const handleKeyDown = useCallback((e: KeyboardEvent<HTMLTextAreaElement>): void => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  }, []);

  // Send message
  const handleSendMessage = useCallback(async (): Promise<void> => {
    if (sendingRef.current || isSending) return;

    const trimmedText = text.trim();
    if (!trimmedText && attachments.length === 0 && !selectedLocation && !giftAttachment) {
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      return;
    }

    try {
      sendingRef.current = true;
      setIsSending(true);

      // Check points for male users
      if (gender === 'male' && requiredPoints > 0) {
        if (!validatePoints(requiredPoints)) return;
      }

      // Create message object
      const message: Message = {
        text: trimmedText,
        attachments: [...attachments],
        createdAt: new Date(),
      };

      if (selectedLocation) {
        message.location = selectedLocation;
      }

      if (selectedGift) {
        message.gift = selectedGift;
      }

      // Send message
      await onSendMessage(message);

      // Update points for male users
      if (gender === 'male' && requiredPoints > 0) {
        const newPoints = localPoints - requiredPoints;
        setLocalPoints(newPoints);
        onPointsUpdated(newPoints);
      }

      // Reset state
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      setGiftAttachment(null);
      setSelectedGift(null);
      if (onTypingEnd) onTypingEnd();

    } catch (error) {
      console.error('Failed to send message:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [text, attachments, selectedLocation, giftAttachment, selectedGift, gender, requiredPoints, localPoints, onSendMessage, onPointsUpdated, onTypingEnd, validatePoints]);


  const MessageInput = React.forwardRef<HTMLDivElement, MessageInputProps>((
  {
    onSendMessage,
    onTypingStart,
    onTypingEnd,
    disabled = false,
    placeholder = 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›',
    gender,
    currentPoints,
    requiredPoints,
    onPointsUpdated,
    chatId
  },
  ref
) => {
  // State
  const [text, setText] = useState<string>('');
  const [attachments, setAttachments] = useState<Attachment[]>([]);
  const [selectedLocation, setSelectedLocation] = useState<Location | null>(null);
  const [giftAttachment, setGiftAttachment] = useState<GiftAttachment | null>(null);
  const [selectedGift, setSelectedGift] = useState<Gift | null>(null);
  const [showGiftSelector, setShowGiftSelector] = useState<boolean>(false);
  const [showGiftAnimation, setShowGiftAnimation] = useState<boolean>(false);
  const [currentAnimation, setCurrentAnimation] = useState<string>('');
  const [isSending, setIsSending] = useState<boolean>(false);
  const [localPoints, setLocalPoints] = useState<number>(currentPoints);
  const [isAttachmentMenuOpen, setIsAttachmentMenuOpen] = useState<boolean>(false);
  const [isEmoticonPickerOpen, setIsEmoticonPickerOpen] = useState<boolean>(false);
  const [activeEmojiCategory, setActiveEmojiCategory] = useState<string>('smileys');

  // Refs
  const sendingRef = useRef<boolean>(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const attachmentButtonRef = useRef<HTMLButtonElement>(null);
  const emoticonButtonRef = useRef<HTMLButtonElement>(null);
  const giftButtonRef = useRef<HTMLButtonElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout>();



  // Message handlers
  const handleTextChange = useCallback((e: ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    if (onTypingStart) {
      onTypingStart();
    }

    typingTimeoutRef.current = setTimeout(() => {
      if (onTypingEnd) {
        onTypingEnd();
      }
    }, 1000);
  }, [onTypingStart, onTypingEnd]);

  const handleGiftClick = useCallback(() => {
    if (gender === 'male' && requiredPoints && !validatePoints(requiredPoints)) {
      return;
    }
    setShowGiftSelector(true);
  }, [gender, requiredPoints, validatePoints]);

  const handleGiftSelect = useCallback(async (gift: Gift, message?: string) => {
    if (!gift || !validateGift(gift)) return;

    try {
      const newPoints = localPoints - gift.price;
      setLocalPoints(newPoints);
      onPointsUpdated?.(newPoints);

      const newGiftAttachment: GiftAttachment = {
        id: `gift-${Date.now()}`,
        type: 'gift',
        giftId: gift.id,
        url: gift.imageUrl,
        name: gift.name,
        size: 0,
        gift,
        price: gift.price,
        createdAt: new Date()
      };

      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);
      setText(message || '');
      setShowGiftSelector(false);

      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
      }
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé¸æŠã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é¸æŠä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    }
  }, [localPoints, onPointsUpdated, validateGift]);


      setIsSending(true);

      const message: Message = {
        text: text.trim(),
        attachments: [...attachments],
        createdAt: new Date()
      };

      if (selectedLocation) {
        message.location = selectedLocation;
      }

      if (giftAttachment) {
        message.attachments.push(giftAttachment);
      }

      await onSendMessage(message);

      // Reset state after successful send
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      setGiftAttachment(null);
      setSelectedGift(null);
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [text, attachments, selectedLocation, giftAttachment, onSendMessage]);




  // Validate required props
  if (!onSendMessage || !onPointsUpdated || typeof currentPoints !== 'number') {
    console.error('Required props missing in MessageInput');
    return <div ref={ref}>Error: Required props missing</div>;
  }



  // Handlers
  const handleTextChange = useCallback((e: ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    if (onTypingStart) {
      onTypingStart();
    }

    typingTimeoutRef.current = setTimeout(() => {
      if (onTypingEnd) {
        onTypingEnd();
      }
    }, 1000);
  }, [onTypingStart, onTypingEnd]);


      setIsSending(true);

      const message: Message = {
        text: text.trim(),
        attachments: [...attachments],
        createdAt: new Date()
      };

      if (selectedLocation) {
        message.location = selectedLocation;
      }

      if (giftAttachment) {
        message.attachments.push(giftAttachment);
      }

      await onSendMessage(message);

      // Reset state after successful send
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      setGiftAttachment(null);
      setSelectedGift(null);
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [text, attachments, selectedLocation, giftAttachment, onSendMessage]);

  // Effects
  useEffect(() => {
    setLocalPoints(currentPoints);
  }, [currentPoints]);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        attachmentButtonRef.current &&
        !attachmentButtonRef.current.contains(event.target as Node)
      ) {
        setIsAttachmentMenuOpen(false);
      }
    };

    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, []);

  // Update local points when prop changes
  useEffect(() => {
    setLocalPoints(currentPoints);
  }, [currentPoints]);

  // Validation functions
  const validatePoints = useCallback((points: number): boolean => {
    if (!points || points <= 0) return false;
    if (gender === 'male' && localPoints < points) {
      toast.error(`ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦ãƒã‚¤ãƒ³ãƒˆ: ${points}ï¼‰`);
      return false;
    }
    return true;
  }, [localPoints, gender]);

  const validateGift = useCallback((gift: Gift | null): boolean => {
    if (!gift || !gift.price) {
      toast.error('ã‚®ãƒ•ãƒˆã®æƒ…å ±ãŒä¸æ­£ã§ã™');
      return false;
    }
    
    if (!gift.imageUrl || !validateGiftImageUrl(gift.imageUrl)) {
      toast.error('ã‚®ãƒ•ãƒˆç”»åƒãŒç„¡åŠ¹ã§ã™');
      return false;
    }

    if (gender === 'male') {
      return validatePoints(gift.price);
    }

    return true;
  }, [gender, validatePoints]);

  // Validation functions
  const validatePoints = useCallback((points: number): boolean => {
    if (!points || points <= 0) return false;
    if (localPoints < points) {
      toast.error(`ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦ãƒã‚¤ãƒ³ãƒˆ: ${points}ï¼‰`);
      return false;
    }
    return true;
  }, [localPoints]);

  const validateGift = useCallback((gift: Gift): boolean => {
    if (!gift) {
      toast.error('ã‚®ãƒ•ãƒˆãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“');
      return false;
    }

    if (!gift.imageUrl || !validateGiftImageUrl(gift.imageUrl)) {
      toast.error('ã‚®ãƒ•ãƒˆç”»åƒãŒç„¡åŠ¹ã§ã™');
      return false;
    }

    if (gender === 'male' && gift.price) {
      if (!validatePoints(gift.price)) {
        return false;
      }
    }

    return true;
  }, [gender, validatePoints]);

  // Refs
  const sendingRef = useRef<boolean>(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const videoInputRef = useRef<HTMLInputElement>(null);
  const messageInputRef = useRef<HTMLTextAreaElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout>();
  const attachmentMenuRef = useRef<HTMLDivElement>(null);
  const attachmentButtonRef = useRef<HTMLButtonElement>(null);
  const emoticonPickerRef = useRef<HTMLDivElement>(null);

  // Validation functions
  const validatePoints = useCallback((points: number): boolean => {
    if (!points || points <= 0) return false;
    if (localPoints < points) {
      toast.error(`ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦ãƒã‚¤ãƒ³ãƒˆ: ${points}ï¼‰`);
      return false;
    }
    return true;
  }, [localPoints]);

  const validateGift = useCallback((gift: Gift): boolean => {
    if (!gift) {
      toast.error('ã‚®ãƒ•ãƒˆãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“');
      return false;
    }

    if (!gift.imageUrl || !validateGiftImageUrl(gift.imageUrl)) {
      toast.error('ã‚®ãƒ•ãƒˆç”»åƒãŒç„¡åŠ¹ã§ã™');
      return false;
    }

    if (gender === 'male' && gift.price) {
      if (!validatePoints(gift.price)) {
        toast.error(`ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦ãƒã‚¤ãƒ³ãƒˆ: ${gift.price}ï¼‰`);
        return false;
      }
    }

    return true;
  }, [gender, validatePoints]);

  // Update local points when props change
  useEffect(() => {
    setLocalPoints(currentPoints);
  }, [currentPoints]);

  // Update local points when props change
  useEffect(() => {
    setLocalPoints(currentPoints);
  }, [currentPoints]);

  // Handle typing status
  useEffect(() => {
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    if (text && onTypingStart) {
      onTypingStart();
      typingTimeoutRef.current = setTimeout(() => {
        if (onTypingEnd) onTypingEnd();
      }, 1000);
    } else if (!text && onTypingEnd) {
      onTypingEnd();
    }

    return () => {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    };
  }, [text, onTypingStart, onTypingEnd]);

  const validateGift = useCallback((gift: Gift): boolean => {
    if (!gift) {
      toast.error('ã‚®ãƒ•ãƒˆãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“');
      return false;
    }

    if (!gift.imageUrl || !validateGiftImageUrl(gift.imageUrl)) {
      toast.error('ã‚®ãƒ•ãƒˆç”»åƒãŒç„¡åŠ¹ã§ã™');
      return false;
    }

    if (gender === 'male' && gift.price) {
      if (!validatePoints(gift.price)) {
        return false;
      }
    }
    return true;
  }, [gender, validatePoints]);

  // Handle sending messages


  // Handle file upload
  const uploadFile = async (file: File, type: FileType): Promise<FileUploadResult> => {
    try {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('type', type);

      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        throw new Error('ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      const result = await response.json();
      return {
        url: result.url,
        thumbnailUrl: type === 'video' ? result.thumbnailUrl : undefined
      };
    } catch (error) {
      console.error('ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
      throw new Error('ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  };
      return validatePoints(gift.price);
    }

    return true;
  }, [gender, validatePoints]);



  // Event handlers
  const handleTextChange = useCallback((e: ChangeEvent<HTMLTextAreaElement>) => {
    setText(e.target.value);
  }, [setText]);

  // Event handlers for attachments
  const handleImageAttachment = useCallback(async (e: ChangeEvent<HTMLInputElement>): Promise<void> => {
    if (!e.target.files?.length) return;
    
    const file = e.target.files[0];
    if (!file.type.startsWith('image/')) {
      toast.error('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
      return;
    }

    try {
      const formData = new FormData();
      formData.append('image', file);
      
      const response = await fetch('/api/upload/image', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        throw new Error('ç”»åƒã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
      
      const { url } = await response.json();
      
      const newAttachment: ImageAttachment = {
        type: 'image',
        url,
        createdAt: new Date(),
        id: `image-${Date.now()}`
      };
      
      setAttachments(prev => [...prev, newAttachment]);
    } catch (error) {
      console.error('Failed to upload image:', error);
      toast.error('ç”»åƒã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, []);
      const imageUrl = await validateGiftImageUrl(URL.createObjectURL(file));
      if (!imageUrl) {
        toast.error('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
        return;
      }

      const newAttachment: ImageAttachment = {
        id: Date.now().toString(),
        type: 'image',
        url: imageUrl,
        createdAt: new Date()
      };

      setAttachments(prev => [...prev, newAttachment]);
    } catch (error) {
      console.error('ç”»åƒæ·»ä»˜ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ç”»åƒã®æ·»ä»˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, []);



  const handleLocationAttachment = useCallback(async (): Promise<void> => {
    if (!navigator.geolocation) {
      toast.error('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
      return;
    }

    try {
      const position = await new Promise<GeolocationPosition>((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject);
      });

      const location: Location = {
        latitude: position.coords.latitude,
        longitude: position.coords.longitude
      };

      setSelectedLocation(location);
    } catch (error) {
      console.error('ä½ç½®æƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, []);



  const formatDuration = useCallback((seconds: number): string => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  }, []);



  // Event Handlers

      setIsSending(true);

      const currentAttachments = giftAttachment ? [...attachments, giftAttachment] : attachments;
      await onSendMessage(text, currentAttachments, selectedLocation);

      // Reset states after successful send
      setText('');
      setAttachments([]);
      setSelectedLocation(undefined);
      setSelectedGift(null);
      setGiftAttachment(null);
      setShowGiftAnimation(false);
      setCurrentAnimation('');
      onTypingEnd?.();

      // Update points if gift was sent
      if (selectedGift && gender === 'male') {
        onPointsUpdated(currentPoints - selectedGift.price);
      }
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [text, attachments, selectedLocation, selectedGift, gender, currentPoints, isSending, onSendMessage, onPointsUpdated, onTypingEnd, giftAttachment]);

  const handleTextChange = useCallback((e: ChangeEvent<HTMLTextAreaElement>): void => {
    const newText = e.target.value;
    setText(newText);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    if (newText.trim()) {
      onTypingStart?.();
      typingTimeoutRef.current = setTimeout(() => {
        onTypingEnd?.();
      }, 1000);
    } else {
      onTypingEnd?.();
    }
  }, [onTypingStart, onTypingEnd]);



  const handleGiftClick = useCallback((): void => {
    if (!validatePoints(requiredPoints)) return;
    setShowGiftSelector(true);
  }, [validatePoints, requiredPoints]);

  const handleGiftSelect = useCallback(async (selectedGift: Gift, message?: string): Promise<void> => {
    if (sendingRef.current || isSending || !selectedGift || !onPointsUpdated) return;
    
    // ã‚®ãƒ•ãƒˆã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!validateGift(selectedGift)) return;
    
    try {
      const newPoints = localPoints - selectedGift.price;
      setLocalPoints(newPoints);
      onPointsUpdated(newPoints);
      
      const newGiftAttachment: GiftAttachment = {
        id: `gift-${Date.now()}`,
        type: 'gift',
        gift: selectedGift,
        price: selectedGift.price,
        createdAt: new Date()
      };
      
      setGiftAttachment(newGiftAttachment);
      setSelectedGift(selectedGift);
      setText(message || '');
      setShowGiftSelector(false);
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
      setCurrentAnimation(selectedGift.animation || '');
      setShowGiftAnimation(true);
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé¸æŠã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é¸æŠä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    }
    
    try {
      const newGiftAttachment: GiftAttachment = {
        id: `gift-${Date.now()}`,
        type: 'gift',
        gift: selectedGift,
        price: selectedGift.price || 0,
        createdAt: new Date()
      };
      
      setGiftAttachment(newGiftAttachment);
      setSelectedGift(selectedGift);
      if (message) setText(message);
      setShowGiftSelector(false);
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤º
      setCurrentAnimation(selectedGift.animation || 'default');
      setShowGiftAnimation(true);

      toast.success('ã‚®ãƒ•ãƒˆã‚’é¸æŠã—ã¾ã—ãŸ');
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé¸æŠã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é¸æŠä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    }
  }, [isSending, setText, setGiftAttachment, setSelectedGift, setShowGiftSelector, setCurrentAnimation, setShowGiftAnimation, validateGift]);
  }, [isSending, setText, setGiftAttachment, setSelectedGift, setShowGiftSelector, setCurrentAnimation, setShowGiftAnimation, validateGift]);
      return;
    }

    try {
      sendingRef.current = true;
      setIsSending(true);

      const newGiftAttachment: GiftAttachment = {
        id: `gift-${Date.now()}`,
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl: validateGiftImageUrl(gift.imageUrl),
        price: gift.price,
        message: text || undefined,
        animation: gift.animation,
        createdAt: new Date()
      };

      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);
      setShowGiftSelector(false);

      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
        await new Promise(resolve => setTimeout(resolve, 3000));
      }

      await handleSendMessage();
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [validateGift, validatePoints, isSending, handleSendMessage, text]);

  const toggleAttachmentMenu = useCallback((): void => {
    setIsAttachmentMenuOpen(!isAttachmentMenuOpen);
  }, [isAttachmentMenuOpen]);

  const handleImageAttachment = useCallback(async (e: ChangeEvent<HTMLInputElement>): Promise<void> => {
    if (!e.target.files?.length) return;

    const file = e.target.files[0];
    if (!file.type.startsWith('image/')) {
      toast.error('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
      return;
    }

    try {
      const imageUrl = URL.createObjectURL(file);
      if (await isValidImageUrl(imageUrl)) {
        const newAttachment: ImageAttachment = {
          id: `image-${Date.now()}`,
          type: 'image',
          url: imageUrl,
          createdAt: new Date(),
        };
        setAttachments([...attachments, newAttachment]);
      } else {
        toast.error('ç„¡åŠ¹ãªç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã§ã™');
      }
    } catch (error) {
      console.error('ç”»åƒæ·»ä»˜ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ç”»åƒã®æ·»ä»˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, [attachments]);

  const handleVideoAttachment = useCallback(async (e: ChangeEvent<HTMLInputElement>): Promise<void> => {
    if (!e.target.files?.length) return;

    const file = e.target.files[0];
    if (!file.type.startsWith('video/')) {
      toast.error('å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
      return;
    }

    try {
      const videoUrl = URL.createObjectURL(file);
      const newAttachment: VideoAttachment = {
        id: `video-${Date.now()}`,
        type: 'video',
        url: videoUrl,
        createdAt: new Date(),
      };
      setAttachments([...attachments, newAttachment]);
    } catch (error) {
      console.error('å‹•ç”»æ·»ä»˜ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('å‹•ç”»ã®æ·»ä»˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, [attachments]);

  const handleLocationAttachment = useCallback(async (): Promise<void> => {
    if (!navigator.geolocation) {
      toast.error('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
      return;
    }

    try {
      const position = await new Promise<GeolocationPosition>((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject);
      });

      const { latitude, longitude } = position.coords;
      setSelectedLocation({ latitude, longitude });
    } catch (error) {
      console.error('ä½ç½®æƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, []);

  const handleEmoticonMenu = useCallback((): void => {
    setIsEmoticonPickerOpen(!isEmoticonPickerOpen);
  }, [isEmoticonPickerOpen]);

  const handleEmojiSelect = useCallback((emoji: string): void => {
    setText((prev: string) => prev + emoji);
  }, []);

  const handleCategorySelect = useCallback((category: string): void => {
    setActiveEmojiCategory(category);
  }, []);

  const handleRemoveAttachment = useCallback((index: number): void => {
    setAttachments(attachments.filter((_, i) => i !== index));
  }, [attachments]);

  const handleCancelLocation = useCallback((): void => {
    setSelectedLocation(undefined);
  }, []);

  const triggerImageAttachment = useCallback((): void => {
    fileInputRef.current?.click();
  }, []);

  const triggerVideoAttachment = useCallback((): void => {
    videoInputRef.current?.click();
  }, []);

  const handleClickOutside = useCallback((event: MouseEvent): void => {
    if (
      attachmentMenuRef.current &&
      !attachmentMenuRef.current.contains(event.target as Node) &&
      attachmentButtonRef.current &&
      !attachmentButtonRef.current.contains(event.target as Node)
    ) {
      setIsAttachmentMenuOpen(false);
    }
  }, []);       type: 'video',
        url: videoUrl,
        createdAt: new Date(),
      };
      setAttachments([...attachments, newAttachment]);
    } catch (error) {
      console.error('å‹•ç”»æ·»ä»˜ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('å‹•ç”»ã®æ·»ä»˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, [attachments]);

  const handleLocationAttachment = useCallback(async (): Promise<void> => {
    if (!navigator.geolocation) {
      toast.error('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
      return;
    }

    try {
      const position = await new Promise<GeolocationPosition>((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject);
      });

      const { latitude, longitude } = position.coords;
      const locationData: LocationData = {
        latitude,
        longitude,
      };

      setSelectedLocation(locationData);
      const newAttachment: LocationAttachment = {
        id: `location-${Date.now()}`,
        type: 'location',
        ...locationData,
        createdAt: new Date(),
      };
      setAttachments([...attachments, newAttachment]);
    } catch (error) {
      console.error('ä½ç½®æƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, [attachments]);

  const handleEmoticonMenu = useCallback((e: React.MouseEvent): void => {
    e.preventDefault();
    setIsEmoticonPickerOpen(!isEmoticonPickerOpen);
  }, [isEmoticonPickerOpen]);

  const handleEmojiSelect = useCallback((e: React.MouseEvent, emoji: string): void => {
    e.preventDefault();
    setText((prev) => prev + emoji);
  }, []);

  const handleCategorySelect = useCallback((e: React.MouseEvent, category: string): void => {
    e.preventDefault();
    setActiveEmojiCategory(category);
  }, []);

  const handleRemoveAttachment = useCallback((index: number): void => {
    setAttachments(attachments.filter((_, i) => i !== index));
  }, [attachments]);

  const handleCancelLocation = useCallback((): void => {
    setSelectedLocation(undefined);
  }, []);

  const triggerImageAttachment = useCallback((): void => {
    fileInputRef.current?.click();
  }, []);

  const triggerVideoAttachment = useCallback((): void => {
    videoInputRef.current?.click();
  }, []);

  // Event Handlers

      setIsSending(true);

      if (text.trim() || attachments.length > 0 || selectedGift) {
        await onSendMessage(text.trim(), attachments, selectedLocation);
        
        // Update points if gift was sent
        if (selectedGift && currentPoints >= requiredPoints) {
          onPointsUpdated?.(currentPoints - requiredPoints);
        }

        // Reset states
        setText('');
        setAttachments([]);
        setSelectedLocation(undefined);
        setGiftAttachment(null);
        setSelectedGift(null);
        setShowGiftSelector(false);
        setShowGiftAnimation(false);
        onTypingEnd?.();

        // Show success toast
        toast.success(
          <div className="flex items-center space-x-2">
            <span className="text-lg">âœ¨</span>
            <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã—ãŸ</span>
          </div>
        );
      }
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error(
        <div className="flex items-center space-x-2">
          <MdWarning className="text-lg" />
          <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ</span>
        </div>
      );
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [text, attachments, selectedLocation, selectedGift, currentPoints, requiredPoints, onSendMessage, onPointsUpdated, onTypingEnd]);



  const handleKeyDown = useCallback((e: KeyboardEvent<HTMLTextAreaElement>): void => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      void handleSendMessage();
    }
  }, [handleSendMessage]);

  const handleGiftClick = useCallback((): void => {
    if (!validatePoints(requiredPoints)) return;
    setShowGiftSelector(true);
  }, [validatePoints, requiredPoints]);

  // é‡è¤‡é–¢æ•°ã‚’å‰Šé™¤
    }

    try {
      sendingRef.current = true;
      setIsSending(true);

      const giftImageUrl = validateGiftImageUrl(gift.imageUrl);
      const newGiftAttachment: GiftAttachment = {
        id: crypto.randomUUID(),
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl,
        price: gift.price,
        message: text.trim() || undefined,
        animation: gift.animation,
        createdAt: new Date()
      };

      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);

      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
      }

      await onSendMessage(text.trim(), [newGiftAttachment]);
      onPointsUpdated?.(currentPoints - gift.price);

      setText('');
      setShowGiftSelector(false);
      setShowGiftAnimation(false);
      toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [currentPoints, isSending, onPointsUpdated, onSendMessage, text, validateGift, validatePoints]);



  // Event Handlers


    try {
      if (text.trim() || attachments.length > 0 || selectedGift) {
        // Send message
        await onSendMessage(text, attachments, selectedLocation);
        
        // Update points if gift was sent
        if (selectedGift && currentPoints >= requiredPoints) {
          onPointsUpdated?.(currentPoints - requiredPoints);
        }

        // Reset states
        setText('');
        setAttachments([]);
        setSelectedLocation(undefined);
        setGiftAttachment(null);
        setSelectedGift(null);
        setShowGiftSelector(false);
        setShowGiftAnimation(false);

        // Show success toast
        toast.success(
          <div className="flex items-center space-x-2">
            <span className="text-lg">âœ¨</span>
            <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã—ãŸ</span>
          </div>,
          {
            duration: 2000,
            style: {
              background: '#fff',
              color: '#10b981',
              border: '1px solid #6ee7b7',
            },
          }
        );
      }
    } catch (error) {
      console.error('Error sending message:', error);
      toast.error(
        <div className="flex items-center space-x-2">
          <MdWarning className="text-lg" />
          <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ</span>
        </div>,
        {
          duration: 3000,
          style: {
            background: '#fff',
            color: '#f43f5e',
            border: '1px solid #fecdd3',
          },
        }
      );
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [text, attachments, selectedLocation, selectedGift, currentPoints, requiredPoints, isSending, onSendMessage, onPointsUpdated]);

  // Text input handlers
  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>): void => {
    const newText = e.target.value;
    setText(newText);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    if (newText.trim()) {
      onTypingStart?.();
      typingTimeoutRef.current = setTimeout(() => {
        onTypingEnd?.();
      }, 1000);
    } else {
      onTypingEnd?.();
    }
  }, [onTypingStart, onTypingEnd]);

  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLTextAreaElement>): void => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      void handleSendMessage();
    }
  }, [handleSendMessage]);

  // Gift handlers
  const handleGiftClick = useCallback((): void => {
    if (!validatePoints(requiredPoints)) return;
    setShowGiftSelector(true);
  }, [validatePoints, requiredPoints]);

  // é‡è¤‡é–¢æ•°ã‚’å‰Šé™¤
        id: `gift-${Date.now()}`,
        type: 'gift',
        giftId: selectedGift.id,
        giftName: selectedGift.name,
        giftImageUrl: selectedGift.imageUrl,
        price: selectedGift.price,
        message: text.trim(),
        animation: selectedGift.animation,
        createdAt: new Date()
      };

      if (gender === 'male') {
        onPointsUpdated?.(currentPoints - selectedGift.price);
      }
      await onSendMessage(text.trim(), [newGiftAttachment]);

      setText('');
      setGiftAttachment(newGiftAttachment);
      setSelectedGift(selectedGift);
      setShowGiftSelector(false);

      if (selectedGift.animation) {
        setCurrentAnimation(selectedGift.animation);
        setShowGiftAnimation(true);
      }

      toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, [gender, currentPoints, onPointsUpdated, onSendMessage, text, validateGift, validatePoints]);

  // Menu handlers


  // Text input handlers
  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    if (newText.trim()) {
      onTypingStart?.();
      typingTimeoutRef.current = setTimeout(() => {
        onTypingEnd?.();
      }, 1000);
    } else {
      onTypingEnd?.();
    }
  }, [onTypingStart, onTypingEnd]);

  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  }, [handleSendMessage]);

  // Menu handlers
  const toggleAttachmentMenu = useCallback(() => {
    setIsAttachmentMenuOpen(!isAttachmentMenuOpen);
  }, [isAttachmentMenuOpen]);

  // Gift handlers


  const handleGiftSelect = useCallback(async (gift: Gift) => {
    if (!validateGift(gift) || !validatePoints(gift.price)) return;

    try {
      const newGiftAttachment: GiftAttachment = {
        id: `gift-${Date.now()}`,
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl: gift.imageUrl,
        price: gift.price,
        message: text.trim(),
        animation: gift.animation,
        createdAt: new Date()
      };

      if (gender === 'male') {
        onPointsUpdated?.(currentPoints - gift.price);
      }
      await onSendMessage(text.trim(), [newGiftAttachment]);

      setText('');
      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);
      setShowGiftSelector(false);

      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
      }

      toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, [gender, currentPoints, onPointsUpdated, onSendMessage, text, validateGift, validatePoints]);

  // Handle text input
  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);

    // Handle typing notification
    if (onTypingStart && onTypingEnd) {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
      onTypingStart();
      typingTimeoutRef.current = setTimeout(() => {
        onTypingEnd();
      }, 1000);
    }
  }, [onTypingStart, onTypingEnd]);

  // Handle Enter key press
  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  }, [handleSendMessage]);

  // Toggle attachment menu
  const toggleAttachmentMenu = useCallback(() => {
    setIsAttachmentMenuOpen(!isAttachmentMenuOpen);
  }, [isAttachmentMenuOpen]);

  // Handle gift button click
  const handleGiftClick = useCallback(() => {
    if (!validatePoints(requiredPoints)) return;
    setShowGiftSelector(true);
  }, [gender, currentPoints, requiredPoints]);

  // Handle gift selection
  // é‡è¤‡é–¢æ•°ã‚’å‰Šé™¤
      const newGiftAttachment: GiftAttachment = {
        id: `gift-${Date.now()}`,
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl: gift.imageUrl,
        price: gift.price,
        message: text.trim(),
        animation: gift.animation,
        createdAt: new Date()
      };

      // Update points and send message
      if (gender === 'male') {
        onPointsUpdated(currentPoints - gift.price);
      }
      await onSendMessage(text.trim(), [newGiftAttachment]);

      // Reset states
      setText('');
      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);
      setShowGiftSelector(false);

      // Show animation if available
      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
      }

      toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, [gender, currentPoints, onPointsUpdated, onSendMessage, text]);

  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);

    // Handle typing notification
    if (onTypingStart && onTypingEnd) {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
      onTypingStart();
      typingTimeoutRef.current = setTimeout(() => {
        onTypingEnd();
      }, 1000);
    }
  }, [onTypingStart, onTypingEnd]);

  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  }, [handleSendMessage]);

  const toggleAttachmentMenu = useCallback(() => {
    setIsAttachmentMenuOpen(!isAttachmentMenuOpen);
  }, [isAttachmentMenuOpen]);

  const handleGiftClick = useCallback(() => {
    if (!validatePoints(requiredPoints)) return;
    setShowGiftSelector(true);
  }, [gender, currentPoints, requiredPoints]);

  // é‡è¤‡é–¢æ•°ã‚’å‰Šé™¤
      const newGiftAttachment: GiftAttachment = {
        id: `gift-${Date.now()}`,
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl: gift.imageUrl,
        price: gift.price,
        message: text.trim(),
        animation: gift.animation,
        createdAt: new Date()
      };

      // Update points and send message
      if (gender === 'male') {
        onPointsUpdated(currentPoints - gift.price);
      }
      await onSendMessage(text.trim(), [newGiftAttachment]);

      // Reset states
      setText('');
      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);
      setShowGiftSelector(false);

      // Show animation if available
      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
      }

      toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, [gender, currentPoints, onPointsUpdated, onSendMessage, text]);





  // Memoized handlers
  const handleSendMessage = useCallback(async () => {
    if (isSending || !onSendMessage || sendingRef.current || (!text.trim() && attachments.length === 0)) return;

    try {
      setIsSending(true);
      sendingRef.current = true;

      await onSendMessage(text.trim(), attachments);
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      onTypingEnd?.();

      toast.success(
        <div className="flex items-center space-x-2">
          <span className="text-lg">âœ¨</span>
          <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã—ãŸ</span>
        </div>,
        {
          duration: 2000,
          style: {
            background: '#fff',
            color: '#10b981',
            border: '1px solid #6ee7b7',
          },
        }
      );
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error(
        <div className="flex items-center space-x-2">
          <MdWarning className="text-lg" />
          <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ</span>
        </div>,
        {
          duration: 3000,
          style: {
            background: '#fff',
            color: '#f43f5e',
            border: '1px solid #fecdd3',
          },
        }
      );
    } finally {
      setIsSending(false);
      sendingRef.current = false;
    }
  }, [text, attachments, isSending, onSendMessage, onTypingEnd]);



    try {
      // Check if user has enough points
      if (gender === 'male' && currentPoints < gift.price) {
        toast.error('ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™');
        return;
      }

      // Create gift attachment
      const newGiftAttachment: GiftAttachment = {
        id: `gift-${Date.now()}`,
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl: gift.imageUrl,
        price: gift.price,
        message: text.trim(),
        animation: gift.animation,
        createdAt: new Date()
      };

      // Update points and send message
      if (gender === 'male') {
        onPointsUpdated(currentPoints - gift.price);
      }
      await onSendMessage(text.trim(), [newGiftAttachment]);

      // Reset states
      setText('');
      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);
      setShowGiftSelector(false);

      // Show animation if available
      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
      }

      toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, [gender, currentPoints, onPointsUpdated, onSendMessage, text]);

  // Effects
  useEffect(() => {
    if (showGiftAnimation && currentAnimation) {
      const timer = setTimeout(() => {
        setShowGiftAnimation(false);
        setCurrentAnimation('');
      }, 3000);

      return () => clearTimeout(timer);
    }
  }, [showGiftAnimation, currentAnimation]);

  // Click outside handlers
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as Node;
      const attachmentMenu = document.getElementById('attachment-menu');
      const emoticonPicker = document.getElementById('emoticon-picker');

      if (attachmentMenu && !attachmentMenu.contains(target)) {
        setIsAttachmentMenuOpen(false);
      }
      if (emoticonPicker && !emoticonPicker.contains(target)) {
        setIsEmoticonPickerOpen(false);
      }
    };

    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, []);

  // Helper functions
  const triggerImageAttachment = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const triggerVideoAttachment = useCallback(() => {
    videoInputRef.current?.click();
  }, []);


  // Memoized handlers
  const handleSendMessage = useCallback(async () => {
    if (isSending || !onSendMessage || sendingRef.current || (!text.trim() && attachments.length === 0)) return;

    try {
      setIsSending(true);
      sendingRef.current = true;

      await onSendMessage(text.trim(), attachments);
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      onTypingEnd?.();

      toast.success(
        <div className="flex items-center space-x-2">
          <span className="text-lg">âœ¨</span>
          <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã—ãŸ</span>
        </div>,
        {
          duration: 2000,
          style: {
            background: '#fff',
            color: '#10b981',
            border: '1px solid #6ee7b7',
          },
        }
      );
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error(
        <div className="flex items-center space-x-2">
          <MdWarning className="text-lg" />
          <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ</span>
        </div>,
        {
          duration: 3000,
          style: {
            background: '#fff',
            color: '#f43f5e',
            border: '1px solid #fecdd3',
          },
        }
      );
    } finally {
      setIsSending(false);
      sendingRef.current = false;
    }
  }, [text, attachments, isSending, onSendMessage, onTypingEnd]);

  const handleTextChange = useCallback((e: ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    if (newText.trim()) {
      onTypingStart?.();
      typingTimeoutRef.current = setTimeout(() => {
        onTypingEnd?.();
      }, 1000);
    } else {
      onTypingEnd?.();
    }
  }, [onTypingStart, onTypingEnd]);

  const handleKeyDown = useCallback((e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  }, [handleSendMessage]);

  const toggleAttachmentMenu = useCallback(() => {
    setIsAttachmentMenuOpen(!isAttachmentMenuOpen);
  }, [isAttachmentMenuOpen]);

  const handleGiftClick = useCallback((): void => {
    if (!validatePoints(requiredPoints ?? 0)) {
      return;
    }
    setShowGiftSelector(true);
  }, [validatePoints, requiredPoints]);

  const handleGiftAnimationComplete = useCallback((): void => {
    if (!selectedGift || !giftAttachment || gender !== 'male') return;

    setShowGiftAnimation(false);
    setCurrentAnimation('');

    if (currentPoints < selectedGift.price) {
      toast.error('ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™');
      return;
    }

    onSendMessage(text.trim(), [giftAttachment])
      .then(() => {
        // ç”·æ€§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿ãƒã‚¤ãƒ³ãƒˆã‚’æ¶ˆè²»
        onPointsUpdated(currentPoints - selectedGift.price);
        setText('');
        setShowGiftSelector(false);
        toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');
      })
      .catch((error) => {
        console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
        toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
        // ã‚¨ãƒ©ãƒ¼æ™‚ã«ãƒã‚¤ãƒ³ãƒˆã‚’æˆ»ã™
        onPointsUpdated(currentPoints);
      });
  }, [selectedGift, giftAttachment, text, currentPoints, onSendMessage, onPointsUpdated, gender]);
  }, [gender, currentPoints, requiredPoints]);

  // Gift handling functions
  const validateGift = useCallback((gift: Gift): boolean => {
    if (!gift?.id || !gift?.name || !gift?.imageUrl || !gift?.price) {
      toast.error('ã‚®ãƒ•ãƒˆæƒ…å ±ãŒä¸å®Œå…¨ã§ã™');
      return false;
    }
    return true;
  }, []);

  const validatePoints = useCallback((points: number): boolean => {
    if (gender === 'male' && currentPoints < points) {
      toast.error(
        <div className="flex items-center space-x-2">
          <span className="text-lg">ğŸ’¸</span>
          <span>ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™</span>
        </div>
      );
      return false;
    }
    return true;
  }, [gender, currentPoints]);

  // é‡è¤‡é–¢æ•°ã‚’å‰Šé™¤
    
    try {    
    if (!validatePoints(gift.price)) return;
    
    setSelectedGift(gift);
    setShowGiftAnimation(true);
    setCurrentAnimation('gift-select');
    
    const giftAttach: GiftAttachment = {
      type: 'gift',
      gift,
      price: gift.price,
      url: gift.imageUrl,
    };
    
    setGiftAttachment(giftAttach);
    setShowGiftSelector(false);
    
    if (message) {
      setText(message);
    }
    
    // Points update for male users
    if (gender === 'male') {
      const newPoints = localPoints - gift.price;
      setLocalPoints(newPoints);
      onPointsUpdated(newPoints);
    }
      toast.error('ã‚®ãƒ•ãƒˆæƒ…å ±ãŒä¸å®Œå…¨ã§ã™');
      return;
    }
    
    // ç”·æ€§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆã®ã¿ãƒã‚¤ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
    if (gender === 'male') {
      if (!validatePoints(gift.price)) {
        toast.error(`ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦ãƒã‚¤ãƒ³ãƒˆ: ${gift.price}ï¼‰`);
        return;
      }
      
      // ãƒã‚¤ãƒ³ãƒˆã‚’æ›´æ–°
      const newPoints = localPoints - gift.price;
      setLocalPoints(newPoints);
      onPointsUpdated(newPoints);
    }

    setShowGiftSelector(false);

    try {
      sendingRef.current = true;
      setIsSending(true);

      // Create gift attachment
      const giftImageUrl = await validateGiftImageUrl(gift.imageUrl);
      const newGiftAttachment: GiftAttachment = {
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl,
        price: gift.price,
        message: text || undefined,
        animation: gift.animation,
        createdAt: new Date()
      };

      // Update UI state
      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);

      // Handle gift animation if present
      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
        await new Promise(resolve => setTimeout(resolve, 3000));
      }

      // Send message with gift
      await onSendMessage(text, [newGiftAttachment]);
      
      // Update points based on gender
      if (gender === 'male') {
        onPointsUpdated(currentPoints - gift.price); // Deduct points for male users
      } else if (gender === 'female') {
        onPointsUpdated(currentPoints + gift.price); // Add points for female users
      }
      
      toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');

      // Reset states after successful send
      setText('');
      setShowGiftSelector(false);
      setShowGiftAnimation(false);
      setGiftAttachment(null);
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
      
      // Restore points for male users on error
      if (gender === 'male') {
        onPointsUpdated(currentPoints);
      }
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [currentPoints, isSending, onPointsUpdated, onSendMessage, text, gender, validateGift, validatePoints]);

  const handleGiftClick = useCallback((): void => {
    if (gender === 'male' && currentPoints < requiredPoints) {
      toast.error(
        <div className="flex items-center space-x-2">
          <span className="text-lg">ğŸ’¸</span>
          <span>ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™</span>
        </div>
      );
      return;
    }
    setShowGiftSelector(true);
  }, [gender, currentPoints, requiredPoints]);


      if (!trimmedText && attachments.length === 0 && !selectedLocation && !giftAttachment) {
        toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
      }

      // Check points for male users
      if (gender === 'male' && requiredPoints) {
        if (!validatePoints(requiredPoints)) {
          return;
        }
      }

      sendingRef.current = true;
      setIsSending(true);

      const messageData: Message = {
        text: trimmedText,
        attachments: giftAttachment ? [...attachments, giftAttachment] : attachments,
        location: selectedLocation || undefined,
        createdAt: new Date()
      };

      await onSendMessage(messageData);

      // Update points for male users
      if (gender === 'male' && requiredPoints) {
        const newPoints = localPoints - requiredPoints;
        setLocalPoints(newPoints);
        onPointsUpdated(newPoints);
      }

      // Reset all states
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      setGiftAttachment(null);
      setSelectedGift(null);
      setShowGiftSelector(false);
      setShowGiftAnimation(false);
      setCurrentAnimation('');

      if (onTypingEnd) {
        onTypingEnd();
      }
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
      
      // Restore points for male users on error
      if (gender === 'male' && requiredPoints) {
        setLocalPoints(currentPoints);
        onPointsUpdated(currentPoints);
      }
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [
    text, attachments, selectedLocation, giftAttachment, selectedGift,
    gender, requiredPoints, localPoints, currentPoints,
    onSendMessage, onPointsUpdated, onTypingEnd,
    validatePoints
  ]);
  disabled = false,
  placeholder = 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›',
  gender = 'male',
  currentPoints,
  requiredPoints = 5,
  onPointsUpdated,
  chatId = ''


  // Memoized handlers
  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡å‡¦ç†
  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡å‡¦ç†

      if (!trimmedText && attachments.length === 0 && !selectedLocation && !giftAttachment) {
        toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
      }

      // ãƒã‚¤ãƒ³ãƒˆã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆç”·æ€§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆï¼‰
      if (gender === 'male') {
        if (giftAttachment) {
          if (!validatePoints(giftAttachment.price)) return;
        } else if (requiredPoints) {
          if (!validatePoints(requiredPoints)) return;
        }
      }

      sendingRef.current = true;
      setIsSending(true);

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡
      const message: Message = {
        text: trimmedText,
        attachments: [...attachments],
        location: selectedLocation || undefined,
        createdAt: new Date()
      };

      if (giftAttachment) {
        message.attachments.push(giftAttachment);
      }

      await onSendMessage(message);

      // çŠ¶æ…‹ã®ãƒªã‚»ãƒƒãƒˆ
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      setGiftAttachment(null);
      setSelectedGift(null);
      setShowGiftSelector(false);

      // ãƒã‚¤ãƒ³ãƒˆã®æ›´æ–°ï¼ˆç”·æ€§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆï¼‰
      if (gender === 'male') {
        const deductPoints = giftAttachment ? giftAttachment.price : requiredPoints || 0;
        const newPoints = localPoints - deductPoints;
        setLocalPoints(newPoints);
        onPointsUpdated(newPoints);
      }

      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–¢é€£ã®çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
      setShowGiftAnimation(false);
      setCurrentAnimation('');

      toast.success('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã—ãŸ');
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [
    attachments,
    gender,
    giftAttachment,
    isSending,
    localPoints,
    onPointsUpdated,
    onSendMessage,
    requiredPoints,
    selectedLocation,
    text,
    validatePoints,
    setText,
    setAttachments,
    setSelectedLocation,
    setGiftAttachment,
    setSelectedGift,
    setShowGiftSelector,
    setShowGiftAnimation,
    setCurrentAnimation,
    setLocalPoints
  ]);, onSendMessage, onPointsUpdated, onTypingEnd]);  sendingRef.current = false;
    }
  }, [
    attachments,
    gender,
    giftAttachment,
    isSending,
    localPoints,
    onPointsUpdated,
    onSendMessage,
    selectedLocation,
    setAttachments,
    setGiftAttachment,
    setIsSending,
    setSelectedLocation,
    setShowGiftSelector,
    setText,
    text,
    validatePoints
  ]);
  }, [attachments, gender, giftAttachment, isSending, localPoints, onPointsUpdated, onSendMessage, selectedLocation, text]);
      if (giftAttachment && gender === 'male') {
        if (!validatePoints(giftAttachment.price)) {
          toast.error(`ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦ãƒã‚¤ãƒ³ãƒˆ: ${giftAttachment.price}ï¼‰`);
          return;
        }        }
        
        // ãƒã‚¤ãƒ³ãƒˆã‚’æ›´æ–°
        const newPoints = localPoints - giftAttachment.price;
        setLocalPoints(newPoints);
        onPointsUpdated(newPoints);
      }

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
      sendingRef.current = true;
      setIsSending(true);

      const messageAttachments = giftAttachment ? [...attachments, giftAttachment] : attachments;
      
      await onSendMessage({
        text: trimmedText,
        attachments: messageAttachments,
        location: selectedLocation || undefined,
        createdAt: new Date()
      });

      // æˆåŠŸæ™‚ã®ã‚¯ãƒªã‚¢
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      setGiftAttachment(null);
      setShowGiftSelector(false);
      setShowGiftAnimation(false);
      setCurrentAnimation('');
      
      if (onTypingEnd) {
        onTypingEnd();
      }

    } catch (error) {
      console.error('Failed to send message:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [
    text,
    attachments,
    selectedLocation,
    giftAttachment,
    gender,
    localPoints,
    onSendMessage,
    onPointsUpdated,
    sendingRef,
    isSending,
    setText,
    setAttachments,
    setSelectedLocation,
    setGiftAttachment,
    setShowGiftSelector,
    setIsSending,
    validatePoints,
    createdAt
  ]);
  }, [text, attachments, selectedLocation, giftAttachment, gender, localPoints, onSendMessage, onPointsUpdated]);

      await onSendMessage(text, attachments, selectedLocation);
      
      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡å¾Œã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      setText('');
      setAttachments([]);
      setSelectedLocation(undefined);
      setShowGiftSelector(false);
      
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }

    try {
      if (gender === 'male' && giftAttachment) {
        if (!validatePoints(giftAttachment.price)) {
          return;
        }
      }

      sendingRef.current = true;
      setIsSending(true);

      const currentAttachments = giftAttachment 
        ? [...attachments, giftAttachment]
        : attachments;

      await onSendMessage(text.trim(), currentAttachments, selectedLocation);
      
      // ã‚®ãƒ•ãƒˆé€ä¿¡æ™‚ã®ãƒã‚¤ãƒ³ãƒˆæ›´æ–°
      if (giftAttachment) {
        if (gender === 'male') {
          onPointsUpdated(currentPoints - giftAttachment.price);
        } else if (gender === 'female') {
          onPointsUpdated(currentPoints + giftAttachment.price);
        }
      }

      // Reset states
      setText('');
      setAttachments([]);
      setSelectedLocation(undefined);
      setGiftAttachment(null);
      setSelectedGift(null);
      setShowGiftSelector(false);
      setShowGiftAnimation(false);
      onTypingEnd?.();

      toast.success(
        <div className="flex items-center space-x-2">
          <span className="text-lg">âœ¨</span>
          <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã—ãŸ</span>
        </div>
      );
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error(
        <div className="flex items-center space-x-2">
          <MdWarning className="text-lg" />
          <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ</span>
        </div>
      );

      // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒã‚¤ãƒ³ãƒˆè¿”å´ï¼ˆç”·æ€§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿ï¼‰
      if (gender === 'male' && giftAttachment) {
        onPointsUpdated(currentPoints);
      }
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [text, attachments, selectedLocation, selectedGift, giftAttachment, onSendMessage, onTypingEnd, gender, currentPoints, onPointsUpdated, validatePoints]);

  const handleTextChange = useCallback((e: ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    onTypingStart?.();

    typingTimeoutRef.current = setTimeout(() => {
      onTypingEnd?.();
    }, 1000);
  }, [onTypingStart, onTypingEnd]);

  const handleKeyDown = useCallback((e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  }, [handleSendMessage]);

  const toggleAttachmentMenu = useCallback(() => {
    setIsAttachmentMenuOpen(!isAttachmentMenuOpen);
  }, [isAttachmentMenuOpen]);



    try {
      sendingRef.current = true;
      setIsSending(true);

      const giftImageUrl = validateGiftImageUrl(gift.imageUrl);
      const newGiftAttachment: GiftAttachment = {
        id: crypto.randomUUID(),
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl,
        price: gift.price,
        message: text.trim() || undefined,
        animation: gift.animation,
        createdAt: new Date()
      };

      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);

      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
      }

      await onSendMessage('', [newGiftAttachment]);
      onPointsUpdated(currentPoints - gift.price);
      
      setShowGiftSelector(false);
      setText('');
      setShowGiftAnimation(false);
      setCurrentAnimation('');
      setSelectedGift(null);
      setGiftAttachment(null);
      
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  // é‡è¤‡é–¢æ•°ã‚’å‰Šé™¤
    
    try {    
    if (!validatePoints(gift.price)) return;
    
    setSelectedGift(gift);
    setShowGiftAnimation(true);
    setCurrentAnimation('gift-select');
    
    const giftAttach: GiftAttachment = {
      type: 'gift',
      gift,
      price: gift.price,
      url: gift.imageUrl,
    };
    
    setGiftAttachment(giftAttach);
    setShowGiftSelector(false);
    
    if (message) {
      setText(message);
    }
    
    // Points update for male users
    if (gender === 'male') {
      const newPoints = localPoints - gift.price;
      setLocalPoints(newPoints);
      onPointsUpdated(newPoints);
    }
      toast.error('ã‚®ãƒ•ãƒˆæƒ…å ±ãŒä¸å®Œå…¨ã§ã™');
      return;
    }
    
    // ç”·æ€§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆã®ã¿ãƒã‚¤ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
    if (gender === 'male') {
      if (!validatePoints(gift.price)) {
        toast.error(`ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆå¿…è¦ãƒã‚¤ãƒ³ãƒˆ: ${gift.price}ï¼‰`);
        return;
      }
      
      // ãƒã‚¤ãƒ³ãƒˆã‚’æ›´æ–°
      const newPoints = localPoints - gift.price;
      setLocalPoints(newPoints);
      onPointsUpdated(newPoints);
    }

    setShowGiftSelector(false);

    try {
      sendingRef.current = true;
      setIsSending(true);

      const newGiftAttachment: GiftAttachment = {
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl: gift.imageUrl,
        price: gift.price,
        message: '',
        animation: gift.animation,
        createdAt: new Date()
      };

      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);

      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
      }

      await onSendMessage('', [newGiftAttachment]);
      
      if (gender === 'male') {
        onPointsUpdated(currentPoints - gift.price);
      }

      setText('');
      setShowGiftSelector(false);
      setShowGiftAnimation(false);
      setSelectedGift(null);
      setGiftAttachment(null);
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [currentPoints, gender, isSending, onPointsUpdated, onSendMessage]);
  }, [currentPoints, onPointsUpdated, onSendMessage]);

  // Effects
  useEffect(() => {
    if (showGiftAnimation && currentAnimation) {
      const timer = setTimeout(() => {
        setShowGiftAnimation(false);
        setCurrentAnimation('');
      }, 3000);
      return () => clearTimeout(timer);
    }
  }, [showGiftAnimation, currentAnimation]);

  // Click outside handlers
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as Node;
      const attachmentMenu = document.getElementById('attachment-menu');
      const emoticonPicker = document.getElementById('emoticon-picker');
      
      if (attachmentMenu && !attachmentMenu.contains(target)) {
        setIsAttachmentMenuOpen(false);
      }
      if (emoticonPicker && !emoticonPicker.contains(target)) {
        setIsEmoticonPickerOpen(false);
      }
    };

    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, []);

  // Trigger handlers
  const triggerImageAttachment = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const triggerVideoAttachment = useCallback(() => {
    videoInputRef.current?.click();
  }, []);

  const handleGiftClick = useCallback(() => {
    if (gender === 'male' && requiredPoints) {
      if (!validatePoints(requiredPoints)) {
        return;
      }
    }
    setShowGiftSelector(true);
  }, [gender, validatePoints, requiredPoints]);

  // Event handlers
  const handleTextChange = useCallback((e: ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    onTypingStart?.();

    typingTimeoutRef.current = setTimeout(() => {
      onTypingEnd?.();
    }, 1000);
  }, [onTypingStart, onTypingEnd]);

  const handleKeyDown = useCallback((e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  }, [handleSendMessage]);

  const toggleAttachmentMenu = useCallback(() => {
    setIsAttachmentMenuOpen(!isAttachmentMenuOpen);
  }, [isAttachmentMenuOpen]);



  // ã‚®ãƒ•ãƒˆé€ä¿¡ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleGiftSelect = useCallback(async (gift: Gift): Promise<void> => {
    // Validate gift data
    if (!gift?.id || !gift?.name || !gift?.imageUrl || !gift?.price) {
      toast.error('ã‚®ãƒ•ãƒˆæƒ…å ±ãŒä¸å®Œå…¨ã§ã™');
      return;
    }

    // Check points for male users only
    if (gender === 'male') {
      if (typeof currentPoints !== 'number' || currentPoints < gift.price) {
        toast.error(
          <div className="flex items-center space-x-2">
            <span className="text-lg">ğŸ’¸</span>
            <span>ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™</span>
          </div>,
          {
            duration: 3000,
            style: {
              background: '#fff',
              color: '#f43f5e',
              border: '1px solid #fecdd3',
            },
          }
        );
        return;
      }
    }

    // Check if already sending
    if (isSending || sendingRef.current) {
      toast.error('é€ä¿¡å‡¦ç†ä¸­ã§ã™');
      return;
    }

    try {
      sendingRef.current = true;
      setIsSending(true);

      // Create gift attachment
      const giftImageUrl = await validateGiftImageUrl(gift.imageUrl);
      const newGiftAttachment: GiftAttachment = {
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl,
        price: gift.price,
        message: text || undefined,
        animation: gift.animation,
        createdAt: new Date()
      };

      // Update UI state
      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);

      // Handle gift animation if present
      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
        await new Promise(resolve => setTimeout(resolve, 3000));
      }

      // Send message with gift
      await onSendMessage(text, [newGiftAttachment]);
      
      // Update points based on gender
      if (gender === 'male') {
        onPointsUpdated(currentPoints - gift.price); // Deduct points for male users
      } else {
        onPointsUpdated(currentPoints + gift.price); // Add points for female users
      }
      
      toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');

      // Reset states after successful send
      setText('');
      setShowGiftSelector(false);
      setShowGiftAnimation(false);
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
      
      // Restore points for male users on error
      if (gender === 'male') {
        onPointsUpdated(currentPoints);
      }
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [currentPoints, isSending, onPointsUpdated, onSendMessage, text, gender]);

  // Remove any duplicate handleGiftSelect declarations

  // å‹•ç”»ã®å†ç”Ÿæ™‚é–“ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹é–¢æ•°
  const formatDuration = (seconds: number): string => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  };
  
  // ã‚®ãƒ•ãƒˆé€ä¿¡å‡¦ç†
  const handleGiftClick = useCallback(() => {
    if (gender === 'male' && requiredPoints && !validatePoints(requiredPoints)) {
      return;
    }
    setShowGiftSelector(true);
  }, [gender, requiredPoints, validatePoints]);
        toast.error('ãƒã‚¤ãƒ³ãƒˆæƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“');
        return;
      }
      
      if (localPoints < requiredPoints) {
        toast.error(
        <div className="flex items-center space-x-2">
          <span className="text-lg">ğŸ’¸</span>
          <span>ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™</span>
        </div>,
        {
          duration: 3000,
          style: {
            background: '#fff',
            color: '#f43f5e',
            border: '1px solid #fecdd3',
          },
        }
      );
      return;
    }
        toast.error(
          <div className="flex items-center space-x-2">
            <span className="text-lg">ğŸ’¸</span>
            <span>ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™</span>
          </div>,
          {
            duration: 3000,
            style: {
              background: '#fff',
              color: '#f43f5e',
              border: '1px solid #fecdd3',
            },
          }
        );
        return;
      }
      setShowGiftSelector(true);
    } else {
      toast.error(
        <div className="flex items-center space-x-2">
          <span className="text-lg">âš ï¸</span>
          <span>ã‚®ãƒ•ãƒˆã®é€ä¿¡ã¯ç”·æ€§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿å¯èƒ½ã§ã™</span>
        </div>,
        {
          duration: 3000,
          style: {
            background: '#fff',
            color: '#f43f5e',
            border: '1px solid #fecdd3',
          },
        }
      );
    }
  }, [gender, currentPoints, requiredPoints]);

  // ã‚®ãƒ•ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  useEffect(() => {
    if (showGiftAnimation && currentAnimation) {
      const timer = setTimeout(() => {
        setShowGiftAnimation(false);
        setCurrentAnimation('');
      }, 3000);
      return () => clearTimeout(timer);
    }
  }, [showGiftAnimation, currentAnimation]);

  // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        isAttachmentMenuOpen &&
        event.target instanceof HTMLElement &&
        !event.target.closest('.attachment-menu')
      ) {
        setIsAttachmentMenuOpen(false);
      }
    };


  }, [isAttachmentMenuOpen]);

  // ãƒ•ã‚¡ã‚¤ãƒ«æ·»ä»˜ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
  const toggleAttachmentMenu = useCallback(() => {
    setIsAttachmentMenuOpen(!isAttachmentMenuOpen);
  }, [isAttachmentMenuOpen]);

  // ç”»åƒæ·»ä»˜ãƒˆãƒªã‚¬ãƒ¼
  const triggerImageAttachment = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  // å‹•ç”»æ·»ä»˜ãƒˆãƒªã‚¬ãƒ¼
  const triggerVideoAttachment = useCallback(() => {
    videoInputRef.current?.click();
  }, []);

  // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        isAttachmentMenuOpen &&
        event.target instanceof HTMLElement &&
        !event.target.closest('.attachment-menu')
      ) {
        setIsAttachmentMenuOpen(false);
      }
    };


  }, [isAttachmentMenuOpen]);

  return (
    <div ref={ref} className="relative w-full flex flex-col gap-2 p-4 border-t border-gray-200">
      <div className="flex items-center gap-2">
        <textarea
          ref={textareaRef}
          value={text}
          onChange={handleTextChange}
          onKeyDown={(e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              handleSendMessage();
            }
          }}
          placeholder={placeholder}
          className="flex-1 min-h-[40px] max-h-[120px] p-2 rounded-lg border border-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
          disabled={disabled || isSending}
        />
        <button
          onClick={handleSendMessage}
          disabled={disabled || isSending || (!text && !attachments.length)}
          className={`p-2 rounded-full ${disabled || isSending || (!text && !attachments.length) ? 'bg-gray-200' : 'bg-blue-500 hover:bg-blue-600'}`}
        >
          <RiSendPlaneFill className="w-5 h-5 text-white" />
        </button>
      </div>

      <AnimatePresence>
        {showGiftSelector && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 20 }}
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/50"
          >
            <GiftSelector
              onSelect={handleGiftSelect}
              onClose={() => setShowGiftSelector(false)}
              currentPoints={currentPoints}
            />
          </motion.div>
        )}
      </AnimatePresence>

      <AnimatePresence>
        {showGiftAnimation && currentAnimation && (
          <motion.div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/50"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            <GiftAnimator 
              animation={currentAnimation} 
              onAnimationComplete={() => {
                setShowGiftAnimation(false);
                setCurrentAnimation('');
              }}
            />
          </motion.div>
        )}
      </AnimatePresence>

      <div className="flex items-center gap-2 mt-2">
        <button
          onClick={toggleAttachmentMenu}
          className="p-2 rounded-full hover:bg-gray-100"
          disabled={disabled || isSending}
        >
          <HiPaperClip className="w-5 h-5 text-gray-500" />
        </button>
        <button
          onClick={handleGiftClick}
          className="p-2 rounded-full hover:bg-gray-100"
          disabled={disabled || isSending}
        >
          <HiGift className="w-5 h-5 text-gray-500" />
        </button>
      </div>

      {isAttachmentMenuOpen && (
        <div className="absolute bottom-full left-0 mb-2 bg-white rounded-lg shadow-lg border border-gray-200 p-2 attachment-menu">
          <div className="flex flex-col gap-2">
            <button
              onClick={triggerImageAttachment}
              className="flex items-center gap-2 px-4 py-2 hover:bg-gray-100 rounded-lg"
            >
              <HiPhotograph className="w-5 h-5 text-gray-500" />
              <span>ç”»åƒã‚’æ·»ä»˜</span>
            </button>
            <button
              onClick={triggerVideoAttachment}
              className="flex items-center gap-2 px-4 py-2 hover:bg-gray-100 rounded-lg"
            >
              <HiVideoCamera className="w-5 h-5 text-gray-500" />
              <span>å‹•ç”»ã‚’æ·»ä»˜</span>
            </button>
            <button
              onClick={handleLocationAttachment}
              className="flex items-center gap-2 px-4 py-2 hover:bg-gray-100 rounded-lg"
            >
              <HiLocationMarker className="w-5 h-5 text-gray-500" />
              <span>ä½ç½®æƒ…å ±ã‚’å…±æœ‰</span>
            </button>
          </div>
        </div>
      )}

      <input
        type="file"
        ref={fileInputRef}
        className="hidden"
        accept="image/*"
        onChange={handleImageAttachment}
      />
      <input
        type="file"
        ref={videoInputRef}
        className="hidden"
        accept="video/*"
        onChange={handleVideoAttachment}
      />
    </div>
  );
  
    // ã‚®ãƒ•ãƒˆé€ä¿¡ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleGiftSelect = useCallback(async (gift: Gift) => {
    if (!gift?.id || !gift?.name || !gift?.imageUrl || !gift?.price) {
      toast.error('ã‚®ãƒ•ãƒˆæƒ…å ±ãŒä¸å®Œå…¨ã§ã™');
      return;
    }

    if (currentPoints < gift.price) {
      toast.error('ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™');
      return;
    }

    if (isSending || sendingRef.current) {
      console.log('é€ä¿¡å‡¦ç†ä¸­ã§ã™');
      return;
    }

    try {
      sendingRef.current = true;
      setIsSending(true);

      // ã‚®ãƒ•ãƒˆç”»åƒURLã®å‡¦ç†
      const giftImageUrl = validateGiftImageUrl(gift.imageUrl);

      // ã‚®ãƒ•ãƒˆã‚¢ã‚¿ãƒƒãƒãƒ¡ãƒ³ãƒˆã®ä½œæˆ
      const newGiftAttachment: GiftAttachment = {
        id: crypto.randomUUID(),
        type: 'gift' as const,
        giftId: gift.id,
        giftName: gift.name,
        giftImageUrl,
        price: gift.price,
        message: text || undefined,
        animation: gift.animation,
        createdAt: new Date()
      };

      setGiftAttachment(newGiftAttachment);
      setSelectedGift(gift);

      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®è¡¨ç¤º
      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
        await new Promise(resolve => setTimeout(resolve, 3000));
      }

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡
      await onSendMessage('', [newGiftAttachment]);
      setShowGiftAnimation(false);

      // ãƒã‚¤ãƒ³ãƒˆã®æ›´æ–°
      onPointsUpdated(currentPoints - gift.price);

      // é€ä¿¡æˆåŠŸ
      toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');
      setShowGiftSelector(false);
      setText('');
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
      // ã‚¨ãƒ©ãƒ¼æ™‚ã«ãƒã‚¤ãƒ³ãƒˆã‚’æˆ»ã™
      onPointsUpdated(currentPoints);
    } finally {
      sendingRef.current = false;
      setIsSending(false);
      setSelectedGift(null);
      setGiftAttachment(null);
    }
  }, [currentPoints, isSending, onPointsUpdated, onSendMessage, text]);

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleSendMessage = useCallback(async () => {
    if (isSending || !onSendMessage || sendingRef.current) return;

    try {
      setIsSending(true);
      sendingRef.current = true;

      await onSendMessage(text, attachments);
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      setSelectedGift(null);
      setGiftAttachment(null);
      
      if (onTypingEnd) {
        onTypingEnd();
      }
      toast.success('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã—ãŸ');
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      setIsSending(false);
      sendingRef.current = false;
    }
  }, [text, attachments, selectedLocation, onSendMessage, onTypingEnd, isSending]);

  // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleTextChange = useCallback((e: ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);
    if (onTypingStart) onTypingStart();
  }, [onTypingStart]);

  // ã‚­ãƒ¼å…¥åŠ›ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleKeyDown = useCallback((e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  }, [handleSendMessage]);



      return;
    }

    // é€ä¿¡ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
    setIsSending(true);
    sendingRef.current = true;
    console.log('ã€ã‚®ãƒ•ãƒˆé€ä¿¡ã€‘é€ä¿¡é–‹å§‹');

    // ã‚®ãƒ•ãƒˆæƒ…å ±ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!gift || !gift.id || !gift.name || !gift.imageUrl) {
      console.error('ã€ã‚®ãƒ•ãƒˆé€ä¿¡ã€‘ä¸æ­£ãªã‚®ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿:', gift);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
      setIsSending(false);
      sendingRef.current = false;
      return;
    }

    // ã‚®ãƒ•ãƒˆé€ä¿¡ã®å‡¦ç†
    setShowGiftSelector(false);
    toast.success(
      <div className="flex items-center space-x-2">
        <span className="text-lg">ğŸ</span>
        <span>{giftAttachment.giftName}ã‚’é€ä¿¡ã—ã¾ã—ãŸï¼</span>
      </div>,
      {
        duration: 3000,
        style: {
          background: '#fff',
          color: '#06c755',
          border: '1px solid #06c755',
        },
      }
    );

    try {
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®å‡¦ç†
      if (giftAttachment.animation) {
        setCurrentAnimation(giftAttachment.animation);
        setShowGiftAnimation(true);
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤ºã—ã¦ã‹ã‚‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
        await new Promise(resolve => setTimeout(resolve, 1000));
        await onSendMessage('', [giftAttachment]);
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
        setTimeout(() => {
          setShowGiftAnimation(false);
          setIsSending(false);
          sendingRef.current = false;
          console.log('ã€ã‚®ãƒ•ãƒˆé€ä¿¡ã€‘ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†');
        }, 500);
      } else {
        await onSendMessage('', [giftAttachment]);
        setIsSending(false);
        sendingRef.current = false;
        console.log('ã€ã‚®ãƒ•ãƒˆé€ä¿¡ã€‘é€ä¿¡å®Œäº†');
      }
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
      setIsSending(false);
      sendingRef.current = false;
    }
    
    if (!gift || !gift.id || !gift.name || !gift.imageUrl) {
      toast.error('ã‚®ãƒ•ãƒˆæƒ…å ±ãŒä¸å®Œå…¨ã§ã™');
      return;
    }

    if (isSending || sendingRef.current) {
      console.log('é€ä¿¡å‡¦ç†ä¸­ã§ã™');
      return;
    }

    try {
      sendingRef.current = true;
      setIsSending(true);

      // ãƒã‚¤ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
      if (gift.price > currentPoints) {
        toast.error('ãƒã‚¤ãƒ³ãƒˆãŒä¸è¶³ã—ã¦ã„ã¾ã™');
        return;
      }

      // ã‚®ãƒ•ãƒˆã‚¢ã‚¿ãƒƒãƒãƒ¡ãƒ³ãƒˆã®ä½œæˆ
      const giftAttachment: Attachment = {
        type: 'gift',
        giftId: gift.id,
        giftName: gift.name,
        url: gift.imageUrl,
        animation: gift.animation,
        message: message
      };

      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®è¡¨ç¤º
      if (gift.animation) {
        setCurrentAnimation(gift.animation);
        setShowGiftAnimation(true);
        await new Promise(resolve => setTimeout(resolve, 3000));
      }

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡
      await onSendMessage('', [giftAttachment]);
      setShowGiftAnimation(false);

      // ãƒã‚¤ãƒ³ãƒˆã®æ›´æ–°
      if (onPointsUpdated) {
        onPointsUpdated(currentPoints - gift.price);
      }

      // é€ä¿¡æˆåŠŸ
      toast.success('ã‚®ãƒ•ãƒˆã‚’é€ä¿¡ã—ã¾ã—ãŸ');
      setShowGiftSelector(false);
    } catch (error) {
      console.error('ã‚®ãƒ•ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ã‚®ãƒ•ãƒˆã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      sendingRef.current = false;
      setIsSending(false);
    }
  }, [currentPoints, isSending, onPointsUpdated, onSendMessage]);

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleSendMessage = useCallback(async () => {
    if (isSending || !onSendMessage) return;

    try {
      setIsSending(true);
      await onSendMessage(text, attachments);
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      if (onTypingEnd) onTypingEnd();
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      setIsSending(false);
    }
  }, [text, attachments, selectedLocation, onSendMessage, onTypingEnd, isSending]);

  // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);
    if (onTypingStart && newText.length > 0) onTypingStart();
    if (onTypingEnd && newText.length === 0) onTypingEnd();
  }, [onTypingStart, onTypingEnd]);

  return (
    <div className="relative w-full">
      {/* ã‚®ãƒ•ãƒˆé€ä¿¡ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */}
      {showGiftAnimation && currentAnimation && (
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.8 }}
          className="fixed inset-0 flex items-center justify-center z-50 bg-black/50"
        >
          <Image
            src={currentAnimation}
            alt="ã‚®ãƒ•ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³"
            width={300}
            height={300}
            className="object-contain"
          />
        </motion.div>
      )}

      <div className="flex items-end gap-2 p-4 bg-white border-t">
        <textarea
          value={text}
          onChange={handleTextChange}
          placeholder={placeholder}
          className="flex-1 min-h-[40px] max-h-[120px] p-2 rounded-lg border resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
          disabled={disabled || isSending}
        />
        <button
          onClick={handleSendMessage}
          disabled={disabled || isSending || (!text.trim() && attachments.length === 0)}
          className="p-2 rounded-full bg-blue-500 text-white disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <RiSendPlaneFill className="w-5 h-5" />
        </button>
      </div>

      {/* éè¡¨ç¤ºã®ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ› */}
      <input
        type="file"
        ref={fileInputRef}
        accept="image/*"
        className="hidden"
        onChange={handleFileSelect}
      />
      <input
        type="file"
        ref={videoInputRef}
        accept="video/*"
        className="hidden"
        onChange={handleVideoSelect}
      />

      {/* ã‚®ãƒ•ãƒˆã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ */}
      {showGiftSelector && (
        <GiftSelector
          onSelect={handleGiftSelect}
          onClose={() => setShowGiftSelector(false)}
          currentPoints={currentPoints}
          selectedGift={selectedGift}
        />
      )}
    </div>
  );
}
}

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleSendMessage = useCallback(async () => {
    if (isSending || !onSendMessage) return;

    try {
      setIsSending(true);
      await onSendMessage(text, attachments);
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      if (onTypingEnd) onTypingEnd();
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      setIsSending(false);
    }
  }, [text, attachments, selectedLocation, onSendMessage, onTypingEnd, isSending]);

  // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleTextChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);
    if (onTypingStart && newText.length > 0) onTypingStart();
    if (onTypingEnd && newText.length === 0) onTypingEnd();
  }, [onTypingStart, onTypingEnd]);

  return (
    <div className="relative w-full">
      {/* ã‚®ãƒ•ãƒˆé€ä¿¡ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */}
      {showGiftAnimation && currentAnimation && (
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.8 }}
          className="fixed inset-0 flex items-center justify-center z-50 bg-black/50"
        >
          <Image
            src={currentAnimation}
            alt="ã‚®ãƒ•ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³"
            width={300}
            height={300}
            className="object-contain"
          />
        </motion.div>
      )}

      <div className="flex items-end gap-2 p-4 bg-white border-t">
        <textarea
          value={text}
          onChange={handleTextChange}
          placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..."
          className="flex-1 min-h-[40px] max-h-[120px] p-2 rounded-lg border resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
          disabled={disabled || isSending}
        />
        <button
          onClick={handleSendMessage}
          disabled={disabled || isSending || (!text && attachments.length === 0)}
          className="p-2 rounded-full bg-blue-500 text-white disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <RiSendPlaneFill className="w-5 h-5" />
        </button>
      </div>
    </div>
  );
});

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleSendMessage = useCallback(async () => {
    if (isSending || !onSendMessage) return;

    try {
      setIsSending(true);
      await onSendMessage(text, attachments);
      setText('');
      setAttachments([]);
      setSelectedLocation(null);
      if (onTypingEnd) onTypingEnd();
    } catch (error) {
      console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      setIsSending(false);
    }
  }, [text, attachments, selectedLocation, onSendMessage, onTypingEnd, isSending]);

  return (
    <div className="relative">
      {/* ã‚®ãƒ•ãƒˆé€ä¿¡ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */}
      {showGiftAnimation && currentAnimation && (
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.8 }}
          className="fixed inset-0 flex items-center justify-center z-50 bg-black/50"
        >
          <Image
            src={currentAnimation}
            alt="ã‚®ãƒ•ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³"
            width={300}
            height={300}
            className="object-contain"
          />
        </motion.div>
      )}
    </div>
  );
});
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹å ´åˆã¯è¡¨ç¤º
    if (gift.animation) {
      setCurrentAnimation(gift.animation);
      setShowGiftAnimation(true);
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã«ã‚®ãƒ•ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
      // ç¢ºå®Ÿã«é€ä¿¡ã™ã‚‹ãŸã‚ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’çŸ­ãè¨­å®š
      setTimeout(() => {
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã«ã‚®ãƒ•ãƒˆã‚’é€ä¿¡
        console.log('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã®ã‚®ãƒ•ãƒˆé€ä¿¡é–‹å§‹');
        onSendMessage('', [giftAttachment]);
        console.log('ã‚®ãƒ•ãƒˆé€ä¿¡å®Œäº†');
        setShowGiftAnimation(false);
      }, 1000); // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ã‚’çŸ­ç¸®
    } else {
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒãªã„å ´åˆã¯å³åº§ã«é€ä¿¡
      console.log('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—ã®ã‚®ãƒ•ãƒˆé€ä¿¡');
      onSendMessage('', [giftAttachment]);
      console.log('ã‚®ãƒ•ãƒˆé€ä¿¡å®Œäº†');
    }
  };

  // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ãƒ¼


  // Enterã‚­ãƒ¼ã§ã®é€ä¿¡
  const handleKeyDown = useCallback((e: KeyboardEvent<HTMLTextAreaElement>): void => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      void handleSendMessage();
    }
  }, [handleSendMessage]);

  // ç”»åƒæ·»ä»˜ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleImageAttachment = (e: ChangeEvent<HTMLInputElement>) => {
    // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è‡ªå‹•çš„ã«é–‰ã˜ã‚‹
    setIsAttachmentMenuOpen(false);
    
    if (e.target.files && e.target.files.length > 0) {
      // æ—¢å­˜ã®ç”»åƒæ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«æ•°ã‚’å–å¾—
      const existingImageCount = attachments.filter(a => a.type === 'image').length;
      
      // æœ€å¤§5æšã¾ã§ã®åˆ¶é™ï¼ˆLINEä»•æ§˜ã«æº–æ‹ ï¼‰
      const maxAdditionalImages = 5 - existingImageCount;
      
      if (maxAdditionalImages <= 0) {
        toast.error('ç”»åƒã¯æœ€å¤§5æšã¾ã§ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™');
        return;
      }
      
      // é¸æŠã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†ï¼ˆæœ€å¤§æ•°ã¾ã§ï¼‰
      const filesToProcess = Array.from(e.target.files).slice(0, maxAdditionalImages);
      
      // ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã«å‡¦ç†
      filesToProcess.forEach(file => {
        const reader = new FileReader();
        
        reader.onload = (event) => {
          if (event.target?.result) {
            // æ–°ã—ã„ç”»åƒæ·»ä»˜ã‚’ä½œæˆ
            const newImageAttachment: ImageAttachment = {
              id: `image-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
              type: 'image',
              url: event.target.result as string,
              name: file.name,
              size: file.size,
              file,
              originalWidth: 0,
              originalHeight: 0,
              thumbnailUrl: event.target.result as string,
              createdAt: new Date(),
            };
            
            // ç”»åƒã®ã‚µã‚¤ã‚ºã‚’å–å¾—
            const img = new window.Image();
            img.onload = () => {
              newImageAttachment.originalWidth = img.width;
              newImageAttachment.originalHeight = img.height;
              
              // æ·»ä»˜ãƒªã‚¹ãƒˆã«è¿½åŠ 
              setAttachments(prev => [...prev, newImageAttachment]);
            };
            
            // ç”»åƒã®ã‚½ãƒ¼ã‚¹ã‚’è¨­å®šã—ã¦ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹
            
            img.src = event.target.result as string;
          }
        };
        
        reader.readAsDataURL(file);
      });
    }
    
    // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å†é¸æŠã‚’å¯èƒ½ã«
    if (e.target) {
      e.target.value = '';
    }
  };

  // å‹•ç”»æ·»ä»˜ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleVideoAttachment = (e: ChangeEvent<HTMLInputElement>) => {
    // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è‡ªå‹•çš„ã«é–‰ã˜ã‚‹
    setIsAttachmentMenuOpen(false);
    
    if (e.target.files && e.target.files.length > 0) {
      // æ—¢å­˜ã®å‹•ç”»æ·»ä»˜ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      const hasExistingVideo = attachments.some(a => a.type === 'video');
      
      if (hasExistingVideo) {
        toast.error('å‹•ç”»ã¯1ã¤ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¤ã1ã¤ã ã‘æ·»ä»˜ã§ãã¾ã™');
        return;
      }
      
      const file = e.target.files[0];
      const reader = new FileReader();
      
      reader.onload = (event) => {
        if (event.target?.result) {
          // å‹•ç”»ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®ä¸€æ™‚çš„ãªãƒ“ãƒ‡ã‚ªè¦ç´ 
          const video = document.createElement('video');
          
          video.onloadedmetadata = () => {
            // æ–°ã—ã„å‹•ç”»æ·»ä»˜ã‚’ä½œæˆ
            const newVideoAttachment: VideoAttachment = {
              id: `video-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
              type: 'video',
              url: URL.createObjectURL(file),
              name: file.name,
              size: file.size,
              file,
              duration: video.duration,
              thumbnailUrl: '', // ã‚µãƒ ãƒã‚¤ãƒ«ã¯å®Ÿéš›ã«ã¯å‹•ç”»ã®æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–å¾—ã™ã‚‹å‡¦ç†ãŒå¿…è¦
              createdAt: new Date(),
            };
            
            // æ·»ä»˜ãƒªã‚¹ãƒˆã«è¿½åŠ 
            setAttachments(prev => [...prev, newVideoAttachment]);
          };
          
          video.src = URL.createObjectURL(file);
        }
      };
      
      reader.readAsArrayBuffer(file);
    }
    
    // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å†é¸æŠã‚’å¯èƒ½ã«
    if (e.target) {
      e.target.value = '';
    }
  };

  // ä½ç½®æƒ…å ±æ·»ä»˜
  const handleLocationAttachment = () => {
    // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è‡ªå‹•çš„ã«é–‰ã˜ã‚‹
    setIsAttachmentMenuOpen(false);
    
    // ã‚¸ã‚ªãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³APIãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
    if (navigator.geolocation) {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç¾åœ¨ä½ç½®ã‚’å–å¾—
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const latitude = position.coords.latitude;
          const longitude = position.coords.longitude;
          
          // ä½ç½®æƒ…å ±ã®ãƒªãƒãƒ¼ã‚¹ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆä½æ‰€å–å¾—ï¼‰
          // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€Google Maps APIãªã©ã‚’ä½¿ç”¨ã™ã‚‹ã®ãŒä¸€èˆ¬çš„
          const getAddress = async (lat: number, lng: number) => {
            try {
              // ã“ã®URLã¯å®Ÿéš›ã®APIã‚­ãƒ¼ã§ç½®ãæ›ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
              const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=YOUR_API_KEY`);
              const data = await response.json();
              
              if (data.results && data.results.length > 0) {
                return data.results[0].formatted_address;
              }
              
              return 'ä½æ‰€ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ';
            } catch (error) {
              console.error('ä½æ‰€ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
              return 'ä½æ‰€ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ';
            }
          };
          
          // ç°¡æ˜“çš„ãªå®Ÿè£…ã®ãŸã‚ã€å®Ÿéš›ã®ä½æ‰€å–å¾—ã¯ã‚¹ã‚­ãƒƒãƒ—
          const mockAddress = 'æ±äº¬éƒ½æ¸‹è°·åŒºé“ç„å‚1-12-5';
          
          // æ–°ã—ã„ä½ç½®æƒ…å ±æ·»ä»˜ã‚’ä½œæˆ
          const newLocationAttachment: LocationAttachment = {
            id: `location-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            type: 'location',
            latitude,
            longitude,
            address: mockAddress,
            name: 'ç¾åœ¨åœ°',
            url: `https://www.google.com/maps?q=${latitude},${longitude}`,
            createdAt: new Date(),
          };
          
          // ä½ç½®æƒ…å ±ã®è¡¨ç¤ºã‚’è¨­å®š
          setSelectedLocation(newLocationAttachment);
        },
        (error) => {
          console.error('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
          
          let errorMessage = 'ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
          
          switch (error.code) {
            case error.PERMISSION_DENIED:
              errorMessage = 'ä½ç½®æƒ…å ±ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚è¨­å®šã‹ã‚‰ä½ç½®æƒ…å ±ã®åˆ©ç”¨ã‚’è¨±å¯ã—ã¦ãã ã•ã„ã€‚';
              break;
            case error.POSITION_UNAVAILABLE:
              errorMessage = 'ä½ç½®æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
              break;
            case error.TIMEOUT:
              errorMessage = 'ä½ç½®æƒ…å ±ã®å–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚';
              break;
          }
          
          toast.error(errorMessage);
        }
      );
    } else {
      toast.error('ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ä½ç½®æƒ…å ±ã‚µãƒ¼ãƒ“ã‚¹ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
    }
  };

  // çµµæ–‡å­—ãƒ”ãƒƒã‚«ãƒ¼ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
  const handleEmoticonMenu = (e: React.MouseEvent) => {
    e.stopPropagation(); // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’é˜²æ­¢
    e.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’é˜²æ­¢
    
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¡¨ç¤º
    console.log('çµµæ–‡å­—ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ', {
      ç¾åœ¨ã®çŠ¶æ…‹: isEmoticonPickerOpen ? 'é–‹ã„ã¦ã„ã‚‹' : 'é–‰ã˜ã¦ã„ã‚‹',
      å¤‰æ›´å¾Œ: !isEmoticonPickerOpen ? 'é–‹ã' : 'é–‰ã˜ã‚‹'
    });
    
    // çŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆ
    setIsEmoticonPickerOpen(!isEmoticonPickerOpen);
    
    // æ·»ä»˜ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒé–‹ã„ã¦ã„ã‚Œã°é–‰ã˜ã‚‹
    if (isAttachmentMenuOpen) {
      setIsAttachmentMenuOpen(false);
    }
    
    // å°‘ã—é…å»¶ã•ã›ã¦çŠ¶æ…‹ã‚’ç¢ºèª
    setTimeout(() => {
      console.log('çµµæ–‡å­—ãƒ”ãƒƒã‚«ãƒ¼ã®çŠ¶æ…‹:', isEmoticonPickerOpen ? 'é–‹ã„ã¦ã„ã‚‹' : 'é–‰ã˜ã¦ã„ã‚‹');
    }, 100);
  };
  
  // çµµæ–‡å­—é¸æŠãƒãƒ³ãƒ‰ãƒ©
  const handleEmojiSelect = (e: React.MouseEvent, emoji: string) => {
    e.preventDefault();
    e.stopPropagation();
    setText((prevText) => prevText + emoji);
    // ãƒ”ãƒƒã‚«ãƒ¼ã¯é–‰ã˜ãªã„
  };
  
  // ã‚«ãƒ†ã‚´ãƒªé¸æŠãƒãƒ³ãƒ‰ãƒ©
  const handleCategorySelect = (e: React.MouseEvent, category: string) => {
    e.preventDefault();
    e.stopPropagation();
    setActiveEmojiCategory(category);
    console.log(`${category}ã‚«ãƒ†ã‚´ãƒªãŒé¸æŠã•ã‚Œã¾ã—ãŸ`);
  };

  // æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ã®å‰Šé™¤
  const handleRemoveAttachment = (index: number) => {
    setAttachments(prev => prev.filter((_, i) => i !== index));
  };

  // ä½ç½®æƒ…å ±è¡¨ç¤ºã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  const handleCancelLocation = () => {
    setSelectedLocation(null);
  };

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡å‡¦ç†
  const handleSendMessage = () => {
    if (disabled) return;
    
    // ãƒ†ã‚­ã‚¹ãƒˆã‹æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ã®ã„ãšã‚Œã‹ãŒå¿…è¦
    if (!text && attachments.length === 0 && !selectedLocation) {
      toast('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã™ã‚‹ã‹ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ·»ä»˜ã—ã¦ãã ã•ã„ã€‚', {
        icon: <MdWarning className="text-yellow-500" />,
      });
      return;
    }
    
    // é€ä¿¡ä¸­ã®çŠ¶æ…‹ã‚’è¨­å®š
    setSending(true);
    
    // ä½ç½®æƒ…å ±ãŒã‚ã‚‹å ´åˆã¯æ·»ä»˜ã«è¿½åŠ 
    const allAttachments = [...attachments];
    if (selectedLocation) {
      allAttachments.push(selectedLocation);
    }
    
    // é€ä¿¡å‡¦ç†
    onSendMessage(text, allAttachments);
    
    // å…¥åŠ›ã¨ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
    setText('');
    setAttachments([]);
    setSelectedLocation(null);
    
    // å¿…è¦ã«å¿œã˜ã¦ã‚¿ã‚¤ãƒ”ãƒ³ã‚°çŠ¶æ…‹ã‚’æ›´æ–°
    onTypingEnd?.();
    
    // é€ä¿¡å®Œäº†çŠ¶æ…‹ã«è¨­å®š
    setSending(false);
  };

  // ãƒ•ã‚¡ã‚¤ãƒ«æ·»ä»˜ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
  const toggleAttachmentMenu = useCallback((): void => {
    setIsAttachmentMenuOpen((prev) => !prev);
    if (isEmoticonPickerOpen) {
      setIsEmoticonPickerOpen(false);
    }
  }, [isEmoticonPickerOpen]);

  const handleEmoticonMenu = useCallback((e: React.MouseEvent): void => {
    e.stopPropagation();
    setIsEmoticonPickerOpen((prev) => !prev);
    if (isAttachmentMenuOpen) {
      setIsAttachmentMenuOpen(false);
    }
  }, [isAttachmentMenuOpen]);

  const handleEmojiSelect = useCallback((e: React.MouseEvent, emoji: string): void => {
    e.preventDefault();
    setText((prev) => prev + emoji);
  }, []);

  const handleCategorySelect = useCallback((e: React.MouseEvent, category: string): void => {
    e.preventDefault();
    setActiveEmojiCategory(category);
  }, []);

  const handleRemoveAttachment = useCallback((index: number): void => {
    setAttachments((prev) => prev.filter((_, i) => i !== index));
  }, []);

  const handleCancelLocation = useCallback((): void => {
    setSelectedLocation(undefined);
  }, []);
      setIsEmoticonPickerOpen(false);
    }
    if (isEmoticonPickerOpen) {
      setIsEmoticonPickerOpen(false);
    }
  };
  
  // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as HTMLElement;
      // çµµæ–‡å­—ãƒ”ãƒƒã‚«ãƒ¼ã®å¤–å´ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ãƒ”ãƒƒã‚«ãƒ¼ã‚’é–‰ã˜ã‚‹
      if (isEmoticonPickerOpen && 
          !target.closest('.emoji-picker-container') && 
          !target.closest('button[aria-label="çµµæ–‡å­—"]')) {
        setIsEmoticonPickerOpen(false);
      }
    };
    

  }, [isEmoticonPickerOpen]);

  // ç”»åƒæ·»ä»˜ãƒˆãƒªã‚¬ãƒ¼
  const triggerImageAttachment = () => {
    fileInputRef.current?.click();
  };

  // å‹•ç”»æ·»ä»˜ãƒˆãƒªã‚¬ãƒ¼
  const triggerVideoAttachment = () => {
    videoInputRef.current?.click();
  };

  return (
    <div className="flex flex-col">
      {/* ä½ç½®æƒ…å ±ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */}
      {selectedLocation && (
        <div className="relative mb-4 px-4">
          <div className="bg-white rounded-2xl shadow-md overflow-hidden">
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
              transition={{ duration: 0.3 }}
              className="p-4"
            >
              <div className="flex justify-between items-start mb-2">
                <h3 className="text-lg font-semibold flex items-center">
                  <HiLocationMarker className="text-red-500 mr-2" />
                  {selectedLocation.name || 'ä½ç½®æƒ…å ±'}
                </h3>
                <button
                  onClick={handleCancelLocation}
                  className="text-gray-500 hover:text-gray-700 transition-colors"
                >
                  <IoClose className="w-6 h-6" />
                </button>
              </div>
              
              {/* ä½ç½®æƒ…å ±ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ - LINEé¢¨ */}
              <div className="mb-3">
                <div className="w-full h-40 bg-gray-200 rounded-xl overflow-hidden relative">
                  {/* å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€Google Maps Static API ãªã©ã‚’ä½¿ç”¨ã—ã¦åœ°å›³ç”»åƒã‚’è¡¨ç¤º */}
                  <div className="absolute inset-0 flex items-center justify-center bg-gray-100">
                    <div className="text-center">
                      <HiLocationMarker className="w-10 h-10 text-red-500 mx-auto animate-bounce" />
                      <p className="text-sm text-gray-600 mt-2">åœ°å›³ã‚¤ãƒ¡ãƒ¼ã‚¸ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</p>
                    </div>
                  </div>
                </div>
                <div className="mt-3">
                  <p className="font-semibold text-gray-800">{selectedLocation.name || 'ç¾åœ¨åœ°'}</p>
                  <p className="text-sm text-gray-700 mt-1 bg-gray-50 p-3 rounded-xl border border-gray-100 shadow-sm">
                    {selectedLocation.address || 'ä½æ‰€æƒ…å ±ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ'}
                  </p>
                </div>
              </div>
              
              {/* ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ - LINEé¢¨ */}
              <div className="flex space-x-3 mb-5">
                {selectedLocation.url && (
                  <a 
                    href={selectedLocation.url}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex-1 bg-[#06c755] hover:bg-[#05b64b] text-white font-bold py-3 px-4 rounded-xl text-center transition-all duration-200 transform hover:translate-y-[-2px] shadow-md hover:shadow-lg flex items-center justify-center space-x-2"
                  >
                    <HiLocationMarker className="w-5 h-5" />
                    <span>Google Mapã§è¦‹ã‚‹</span>
                  </a>
                )}
                
                <button
                  onClick={() => {
                    // ã‚·ã‚§ã‚¢æ©Ÿèƒ½ã¯å®Ÿè£…äºˆå®š
                    toast.success(
                      <div className="flex items-center space-x-2">
                        <HiLocationMarker className="w-5 h-5 text-green-500" />
                        <span>ä½ç½®æƒ…å ±ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ</span>
                      </div>,
                      { duration: 3000, style: { background: 'white', color: '#333' } }
                    );
                  }}
                  className="bg-white border border-[#06c755] text-[#06c755] hover:bg-[#06c755] hover:text-white font-bold py-3 px-4 rounded-xl transition-colors duration-200 flex items-center justify-center space-x-1"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                  </svg>
                  <span>ã‚·ã‚§ã‚¢</span>
                </button>
              </div>
              
              {/* ä½ç½®æƒ…å ±è©³ç´° - LINEé¢¨ã‚«ãƒ¼ãƒ‰ãƒ‡ã‚¶ã‚¤ãƒ³ */}
              <div className="text-sm text-gray-600 bg-gray-50 p-4 rounded-xl border border-gray-100 shadow-sm">
                <div className="grid grid-cols-2 gap-4 mb-3">
                  <div>
                    <p className="font-semibold mb-1 text-gray-500">ç·¯åº¦</p>
                    <p className="font-mono text-gray-800 select-all">{selectedLocation.latitude?.toFixed(6)}</p>
                  </div>
                  <div>
                    <p className="font-semibold mb-1 text-gray-500">çµŒåº¦</p>
                    <p className="font-mono text-gray-800 select-all">{selectedLocation.longitude?.toFixed(6)}</p>
                  </div>
                </div>
                <div>
                  <p className="font-semibold mb-1 text-gray-500">å…±æœ‰æ—¥æ™‚</p>
                  <p className="text-gray-800">{selectedLocation.createdAt ? new Date(selectedLocation.createdAt).toLocaleString('ja-JP', { dateStyle: 'medium', timeStyle: 'medium' }) : 'ä¸æ˜'}</p>
                </div>
              </div>
            </motion.div>
          </div>
        </div>
      )}
      
      {/* ãƒ¡ã‚¤ãƒ³å…¥åŠ›ã‚¨ãƒªã‚¢ */}
      <div className="relative flex items-end p-2 border-t border-gray-100">
        {/* ãƒ•ã‚¡ã‚¤ãƒ«æ·»ä»˜ç”¨ã®éš ã—å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ */}
        <input
          type="file"
          ref={fileInputRef}
          onChange={handleImageAttachment}
          style={{ display: 'none' }}
          accept="image/*"
          multiple
        />
        <input
          type="file"
          ref={videoInputRef}
          onChange={handleVideoAttachment}
          style={{ display: 'none' }}
          accept="video/*"
        />
        
        {/* æ·»ä»˜ãƒœã‚¿ãƒ³ */}
        <div className="relative">
          <button
            onClick={toggleAttachmentMenu}
            className={`p-2 rounded-full ${isAttachmentMenuOpen ? 'bg-gray-200' : 'hover:bg-gray-100'} transition-colors`}
            aria-label="ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ·»ä»˜"
          >
            <HiPaperClip className="w-6 h-6 text-gray-600" />
          </button>
          
          {/* æ·»ä»˜ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ */}
          {isAttachmentMenuOpen && (
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 10 }}
              transition={{ duration: 0.2 }}
              className="absolute bottom-full left-0 mb-2 bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden w-64 z-10"
            >
              <div className="p-2 grid grid-cols-2 gap-2">
                {/* ç”»åƒæ·»ä»˜ã‚ªãƒ—ã‚·ãƒ§ãƒ³ */}
                <button
                  onClick={triggerImageAttachment}
                  className="flex flex-col items-center p-3 hover:bg-gray-50 rounded-lg transition-colors"
                >
                  <HiPhotograph className="w-8 h-8 text-blue-500 mb-1" />
                  <span className="text-sm">ç”»åƒ</span>
                </button>
                
                {/* å‹•ç”»æ·»ä»˜ã‚ªãƒ—ã‚·ãƒ§ãƒ³ */}
                <button
                  onClick={triggerVideoAttachment}
                  className="flex flex-col items-center p-3 hover:bg-gray-50 rounded-lg transition-colors"
                >
                  <HiVideoCamera className="w-8 h-8 text-red-500 mb-1" />
                  <span className="text-sm">å‹•ç”»</span>
                </button>
                
                {/* ä½ç½®æƒ…å ±æ·»ä»˜ã‚ªãƒ—ã‚·ãƒ§ãƒ³ */}
                <button
                  onClick={handleLocationAttachment}
                  className="flex flex-col items-center p-3 hover:bg-gray-50 rounded-lg transition-colors"
                >
                  <HiLocationMarker className="w-8 h-8 text-green-500 mb-1" />
                  <span className="text-sm">ä½ç½®æƒ…å ±</span>
                </button>
              </div>
            </motion.div>
          )}
        </div>
        
        {/* ã‚®ãƒ•ãƒˆãƒœã‚¿ãƒ³ - ç”·æ€§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿ */}
        <button
          onClick={handleGiftClick}
          className="p-2 rounded-full hover:bg-gray-100 transition-colors"
          aria-label="ã‚®ãƒ•ãƒˆã‚’é€ã‚‹"
        >
          <HiGift className="w-6 h-6 text-pink-500" />
        </button>
        
        {/* çµµæ–‡å­—ãƒœã‚¿ãƒ³ */}
        <button
          onClick={handleEmoticonMenu}
          className={`p-2 rounded-full ${isEmoticonPickerOpen ? 'bg-gray-200' : 'hover:bg-gray-100'} transition-colors`}
          aria-label="çµµæ–‡å­—ã‚’æŒ¿å…¥"
        >
          <HiEmojiHappy className="w-6 h-6 text-yellow-500" />
        </button>
        
        {/* ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã‚¨ãƒªã‚¢ */}
        <div className="flex-1 mx-2 relative">
          <textarea
            value={text}
            onChange={handleTextChange}
            onKeyDown={handleKeyDown}
            placeholder={placeholder}
            disabled={disabled}
            className={`w-full p-3 rounded-2xl border ${disabled ? 'bg-gray-100 border-gray-200 text-gray-400' : 'bg-white border-gray-200 focus:border-green-500 focus:ring-1 focus:ring-green-500'} resize-none outline-none transition-all`}
            style={{ minHeight: '44px', maxHeight: '120px' }}
            rows={1}
          />
          
          {/* æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */}
          {attachments.length > 0 && (
            <div className="absolute -top-2 left-3 right-3 transform -translate-y-full pb-3">
              <div className="bg-white p-3 rounded-xl shadow-md border border-gray-200">
                <div className="flex flex-wrap gap-2">
                  {attachments.map((attachment, index) => (
                    <div key={index} className="relative">
                      {/* ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */}
                      {attachment.type === 'image' && (
                        <div className="relative w-16 h-16 rounded-lg overflow-hidden border border-gray-200">
                          {attachment.url && attachment.url.trim() !== '' ? (
                            <Image
                              src={attachment.url}
                              alt={attachment.name || `æ·»ä»˜ç”»åƒ ${index + 1}`}
                              fill
                              style={{ objectFit: 'cover' }}
                            />
                          ) : (
                            <div className="w-full h-full flex items-center justify-center bg-gray-200">
                              <span className="text-xs text-gray-500">ç”»åƒãªã—</span>
                            </div>
                          )}
                          <button
                            onClick={() => handleRemoveAttachment(index)}
                            className="absolute top-0 right-0 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center"
                          >
                            <IoClose className="w-4 h-4" />
                          </button>
                        </div>
                      )}
                      
                      {/* å‹•ç”»ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */}
                      {attachment.type === 'video' && (
                        <div className="relative w-24 h-16 rounded-lg overflow-hidden border border-gray-200 bg-black flex items-center justify-center">
                          <div className="absolute inset-0 bg-black opacity-50"></div>
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 text-white z-10" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                          </svg>
                          <div className="absolute bottom-0 right-0 bg-black bg-opacity-70 text-white text-xs px-1 py-0.5">
                            {formatDuration(attachment.duration || 0)}
                          </div>
                          <button
                            onClick={() => handleRemoveAttachment(index)}
                            className="absolute top-0 right-0 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center"
                          >
                            <IoClose className="w-4 h-4" />
                          </button>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
        
        {/* é€ä¿¡ãƒœã‚¿ãƒ³ */}
        <button
          onClick={handleSendMessage}
          disabled={disabled || sending}
          className={`p-2 rounded-full ${disabled ? 'bg-gray-200 text-gray-400 cursor-not-allowed' : 'bg-green-500 text-white hover:bg-green-600'} transition-colors`}
          aria-label="é€ä¿¡"
        >
          <RiSendPlaneFill className="w-6 h-6" />
        </button>
      </div>
      
      {/* ã‚®ãƒ•ãƒˆã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      {showGiftSelector && (
        <GiftSelector
          isOpen={showGiftSelector}
          onClose={() => setShowGiftSelector(false)}
          onSelect={handleGiftSelect}
          context={{
            type: 'chat',
            chatId: chatId // è¦ªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‹ã‚‰æ¸¡ã•ã‚ŒãŸIDã‚’ä½¿ç”¨
          }}
        />
      )}
      
      {/* ã‚®ãƒ•ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤º */}
      {showGiftAnimation && (
        <GiftAnimator 
          animationType={currentAnimation} 
          onAnimationComplete={() => setShowGiftAnimation(false)}
        />
      )}

      {/* çµµæ–‡å­—ãƒ”ãƒƒã‚«ãƒ¼ - ä½ç½®ã¨ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä¿®æ­£ */}
      {isEmoticonPickerOpen && (
        <div 
          className="fixed bottom-20 right-4 z-[1000] emoji-picker-container" 
          style={{ maxWidth: 'calc(100vw - 20px)' }}
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
          }}
          onMouseDown={(e) => {
            e.preventDefault();
            e.stopPropagation();
          }}
        >
          <div 
            className="bg-white rounded-lg shadow-xl border border-gray-200 overflow-hidden"
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
            }}
            onMouseDown={(e) => {
              e.preventDefault();
              e.stopPropagation();
            }}
          >
            {/* æ—¥æœ¬èªã®ãƒ˜ãƒƒãƒ€ãƒ¼ */}
            <div className="bg-indigo-100 p-3 text-sm font-medium text-indigo-800 border-b border-indigo-200 flex justify-between items-center">
              <span>çµµæ–‡å­—ã‚’é¸æŠã—ã¦ãã ã•ã„</span>
              <button 
                onClick={() => setIsEmoticonPickerOpen(false)}
                className="text-indigo-500 hover:text-indigo-700"
              >
                é–‰ã˜ã‚‹
              </button>
            </div>
            
            {/* ã‚«ã‚¹ã‚¿ãƒ UIã§æ—¥æœ¬èªã‚«ãƒ†ã‚´ãƒªã‚¿ãƒ– */}
            <div className="flex overflow-x-auto p-1 border-b border-gray-200 bg-gray-50">
              <button 
                type="button"
                onClick={(e) => handleCategorySelect(e, 'face')}
                className={`px-3 py-1.5 mx-1 text-sm font-medium ${activeEmojiCategory === 'face' ? 'text-indigo-800 bg-indigo-100' : 'text-gray-700 hover:bg-gray-100'} rounded-md whitespace-nowrap`}
              >
                é¡”æ–‡å­—
              </button>
              <button 
                type="button"
                onClick={(e) => handleCategorySelect(e, 'animal')}
                className={`px-3 py-1.5 mx-1 text-sm font-medium ${activeEmojiCategory === 'animal' ? 'text-indigo-800 bg-indigo-100' : 'text-gray-700 hover:bg-gray-100'} rounded-md whitespace-nowrap`}
              >
                å‹•ç‰©ã¨è‡ªç„¶
              </button>
              <button 
                type="button"
                onClick={(e) => handleCategorySelect(e, 'food')}
                className={`px-3 py-1.5 mx-1 text-sm font-medium ${activeEmojiCategory === 'food' ? 'text-indigo-800 bg-indigo-100' : 'text-gray-700 hover:bg-gray-100'} rounded-md whitespace-nowrap`}
              >
                é£Ÿã¹ç‰©
              </button>
              <button 
                type="button"
                onClick={(e) => handleCategorySelect(e, 'heart')}
                className={`px-3 py-1.5 mx-1 text-sm font-medium ${activeEmojiCategory === 'heart' ? 'text-indigo-800 bg-indigo-100' : 'text-gray-700 hover:bg-gray-100'} rounded-md whitespace-nowrap`}
              >
                ãƒãƒ¼ãƒˆ
              </button>
            </div>
            
            {/* ã‚«ã‚¹ã‚¿ãƒ çµµæ–‡å­—ã‚°ãƒªãƒƒãƒ‰ï¼ˆæ—¥æœ¬èªUIï¼‰ */}
            <div className="p-3 grid grid-cols-8 gap-1 h-64 overflow-y-auto">
              {activeEmojiCategory === 'face' && (
                // é¡”æ–‡å­—ã‚«ãƒ†ã‚´ãƒªã®çµµæ–‡å­—
                <>
                  {["ğŸ˜€", "ğŸ˜", "ğŸ˜‚", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜…", "ğŸ˜†", "ğŸ˜‡", "ğŸ˜ˆ", "ğŸ˜‰", "ğŸ˜Š", "ğŸ˜‹", "ğŸ˜Œ", "ğŸ˜", "ğŸ˜", "ğŸ˜", "ğŸ˜", "ğŸ˜‘", "ğŸ˜’", "ğŸ˜“", "ğŸ˜”", "ğŸ˜•", "ğŸ˜–", "ğŸ˜—", "ğŸ˜˜", "ğŸ˜™", "ğŸ˜š", "ğŸ˜›", "ğŸ˜œ", "ğŸ˜", "ğŸ˜", "ğŸ˜Ÿ", "ğŸ˜ ", "ğŸ˜¡", "ğŸ˜¢", "ğŸ˜£", "ğŸ˜¤", "ğŸ˜¥", "ğŸ˜¦", "ğŸ˜§", "ğŸ˜¨", "ğŸ˜©", "ğŸ˜ª", "ğŸ˜«", "ğŸ˜¬", "ğŸ˜­", "ğŸ˜®", "ğŸ˜¯", "ğŸ˜°", "ğŸ˜±", "ğŸ˜²", "ğŸ˜³", "ğŸ˜´", "ğŸ˜µ", "ğŸ˜¶"].map((emoji, index) => (
                    <button 
                      key={index}
                      type="button"
                      className="flex items-center justify-center p-1 text-2xl hover:bg-gray-100 rounded"
                      onClick={(e) => handleEmojiSelect(e, emoji)}
                    >
                      {emoji}
                    </button>
                  ))}
                </>
              )}
              
              {activeEmojiCategory === 'animal' && (
                // å‹•ç‰©ã®çµµæ–‡å­—
                <>
                  {["ğŸ¶", "ğŸ±", "ğŸ­", "ğŸ¹", "ğŸ°", "ğŸ¦Š", "ğŸ»", "ğŸ¼", "ğŸ¨", "ğŸ¯", "ğŸ¦", "ğŸ®", "ğŸ·", "ğŸ½", "ğŸ¸", "ğŸµ", "ğŸ’", "ğŸ˜", "ğŸ”", "ğŸ¦", "ğŸ¤", "ğŸ£", "ğŸ›", "ğŸ", "ğŸœ", "ğŸ", "ğŸŒ", "ğŸ™", "ğŸš", "ğŸ¦‹", "ğŸ", "ğŸ¢", "ğŸ ", "ğŸŸ", "ğŸ¡", "ğŸ¬", "ğŸ³", "ğŸ‹", "ğŸŠ", "ğŸ†", "ğŸ…", "ğŸƒ", "ğŸ‚", "ğŸ„", "ğŸª", "ğŸ«", "ğŸ—", "ğŸ–", "ğŸ•", "ğŸ", "ğŸ‘", "ğŸ", "ğŸ", "ğŸ", "ğŸ‰", "ğŸˆ", "ğŸ“"].map((emoji, index) => (
                    <button 
                      key={`animal-${index}`}
                      type="button"
                      className="flex items-center justify-center p-1 text-2xl hover:bg-gray-100 rounded"
                      onClick={(e) => handleEmojiSelect(e, emoji)}
                    >
                      {emoji}
                    </button>
                  ))}
                </>
              )}
              
              {activeEmojiCategory === 'food' && (
                // é£Ÿã¹ç‰©ã®çµµæ–‡å­—
                <>
                  {["ğŸ", "ğŸ", "ğŸ", "ğŸŠ", "ğŸ‹", "ğŸŒ", "ğŸ‰", "ğŸ‡", "ğŸ“", "ğŸˆ", "ğŸ’", "ğŸ‘", "ğŸ", "ğŸ¥", "ğŸ…", "ğŸ†", "ğŸŒ¶", "ğŸŒ½", "ğŸ„", "ğŸŒ°", "ğŸ‚", "ğŸƒ", "ğŸŒ¿", "ğŸ", "ğŸŒ¾", "ğŸ€", "ğŸŒ¼", "ğŸŒ¸", "ğŸŒ·", "ğŸŒ¹", "ğŸŒº", "ğŸŒ»", "ğŸ•", "ğŸ”", "ğŸŸ", "ğŸ—", "ğŸ–", "ğŸŒ­", "ğŸŒ®", "ğŸŒ¯", "ğŸ³", "ğŸ²", "ğŸ¿", "ğŸ¼", "ğŸ»", "ğŸ·", "ğŸ¸", "ğŸ¹", "ğŸº", "ğŸ¶", "ğŸµ", "ğŸ¾", "ğŸ±", "ğŸ˜", "ğŸš", "ğŸ›", "ğŸœ", "ğŸ", "ğŸ", "ğŸ¢", "ğŸ£", "ğŸ¤", "ğŸ¥", "ğŸ¡", "ğŸ™", "ğŸ ", "ğŸ¦", "ğŸ§", "ğŸ¨", "ğŸ©", "ğŸª", "ğŸ‚", "ğŸ°", "ğŸ«", "ğŸ¬", "ğŸ­", "ğŸ®", "ğŸ¯"].map((emoji, index) => (
                    <button 
                      key={`food-${index}`}
                      type="button"
                      className="flex items-center justify-center p-1 text-2xl hover:bg-gray-100 rounded"
                      onClick={(e) => handleEmojiSelect(e, emoji)}
                    >
                      {emoji}
                    </button>
                  ))}
                </>
              )}
              
              {activeEmojiCategory === 'heart' && (
                // ãƒãƒ¼ãƒˆç³»çµµæ–‡å­—
                <>
                  {["â¤ï¸", "ğŸ’›", "ğŸ’š", "ğŸ’™", "ğŸ’œ", "ğŸ–¤", "ğŸ§¡", "ğŸ’•", "ğŸ’–", "ğŸ’", "ğŸ’“", "ğŸ’—", "ğŸ’˜", "ğŸ’", "ğŸ’Ÿ", "â£ï¸", "ğŸ˜", "ğŸ˜˜", "ğŸ˜—", "ğŸ˜™", "ğŸ˜š", "ğŸ’‹", "ğŸ’Œ", "ğŸ’", "ğŸ’", "ğŸ’", "ğŸ’", "ğŸ’‘", "ğŸ’’", "ğŸ’”", "ğŸ’‹"].map((emoji, index) => (
                    <button 
                      key={`heart-${index}`}
                      type="button"
                      className="flex items-center justify-center p-1 text-2xl hover:bg-gray-100 rounded"
                      onClick={(e) => handleEmojiSelect(e, emoji)}
                    >
                      {emoji}
                    </button>
                  ))}
                </>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
